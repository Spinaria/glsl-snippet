{
    ///Trigonometry 三角学
    "acos 反余弦": {
		"prefix": "acos",
		"body": [
			"acos(${1:value})$2"
		],
		"description": "genType acos(genType x);\n\n返回x的反余弦值\n\n"
	},

    "acosh 反双曲余弦": {
		"prefix": "acosh",
		"body": [
			"acosh(${1:value})$2"
		],
		"description": "genType acosh(genType x);\n\n返回x的反双曲余弦值\n\n"
	},

	"asin 反正弦": {
		"prefix": "asin",
		"body": [
			"asin(${1:value})$2"
		],
		"description": "genType asin(genType x);\n\n返回x的反正弦值\n\n"
	},

	"asinh 反双曲正弦": {
		"prefix": "asinh",
		"body": [
			"asinh(${1:value})$2"
		],
		"description": "genType asinh(genType x);\n\n返回x的反双曲正弦值\n\n"
	},

	"atan 反正切": {
		"prefix": "atan",
		"body": [
			"atan(${1:value})$2"
		],
		"description": "genType atan(genType x);\n\n返回x的反正切值\n\n"
	},

	"atanh 反双曲正切": {
		"prefix": "atanh",
		"body": [
			"atanh(${1:value})$2"
		],
		"description": "genType atanh(genType x);\n\n返回x的反双曲正切值\n\n"
	},

	"cos 余弦": {
		"prefix": "cos",
		"body": [
			"cos(${1:angle})$2"
		],
		"description": "genType cos(genType angle);\n\n返回angle的余弦值\n\n"
	},

	"cosh 双曲余弦": {
		"prefix": "cosh",
		"body": [
			"cosh(${1:value})$2"
		],
		"description": "genType cosh(genType x);\n\n返回x的双曲余弦值\n\n"
	},

	"sin 正弦": {
		"prefix": "sin",
		"body": [
			"sin(${1:angle})$2"
		],
		"description": "genType sin(genType angle);\n\n返回angle的正弦值\n\n"
	},

	"sinh 双曲正弦": {
		"prefix": "sinh",
		"body": [
			"sinh(${1:value})$2"
		],
		"description": "genType sinh(genType x);\n\n返回x的双曲正弦值\n\n"
	},

	"tan 正切": {
		"prefix": "tan",
		"body": [
			"tan(${1:angle})$2"
		],
		"description": "genType tan(genType angle);\n\n返回angle的正切值\n\n"
	},

	"tanh 双曲正切": {
		"prefix": "tanh",
		"body": [
			"tanh(${1:value})$2"
		],
		"description": "genType tanh(genType x);\n\n返回x的双曲正切值\n\n"
	},

	"degrees 弧度 -> 角度": {
		"prefix": "degrees",
		"body": [
			"degrees(${1:radians})$2"
		],
		"description": "genType degrees(genType radians);\n\n把弧度radians换算成角度degress\n\n"
	},

	"radians 角度 -> 弧度": {
		"prefix": "radians",
		"body": [
			"radians(${1:degress})$2"
		],
		"description": "genType radians(genType degrees);\n\n把角度degress换算成弧度radians\n\n"
	},

	//Mathematics 数学

	"abs 绝对值": {
		"prefix": "abs",
		"body": [
			"abs(${1:value})$2"
		],
		"description": "genType abs(genType x);\ngenIType abs(genIType x);\ngenDType abs(genDType x);\n\n返回x的绝对值\n\n"
	},

	"ceil 向上取整": {
		"prefix": "ceil",
		"body": [
			"ceil(${1:value})$2"
		],
		"description": "genType ceil(genType x);\ngenDType ceil(genDType x);\n\n返回x向上取整的值(大于等于x的整数)\n\n"
	},

	"clamp 范围约束": {
		"prefix": "clamp",
		"body": [
			"clamp(${1:value}, ${2:minVal}, ${3:maxVal})$4"
		],
		"description": "genType clamp(genType x,genType minVal,genType maxVal);\ngenType clamp(genType x,float minVal,float maxVal);\ngenDType clamp(genDType x,genDType minVal,genDType maxVal);\ngenDType clamp(genDType x,double minVal,double maxVal);\ngenIType clamp(genIType x,genIType minVal,genIType maxVal);\ngenIType clamp(genIType x,int minVal,int maxVal);\ngenUType clamp(genUType x,genUType minVal,genUType maxVal);\ngenUType clamp(genUType x,uint minVal,uint maxVal);\n\nx:要钳制的值\nminVal:钳制x的下限\nmaxVal:钳制x的上限\n\n\n钳制x至minVal到maxVal之间\n\n"
	},

	"dFdx 偏导数x": {
		"prefix": "dFdx",
		"body": [
			"dFdx(${1:value})$2"
		],
		"description": "genType dFdx(genType p);\ngenType dFdxCoarse(genType p);\ngenType dFdxFine(genType p);\n\np:关于x的偏导数的参数\n\n\n"
	},

	"dFdy 偏导数y": {
		"prefix": "dFdy",
		"body": [
			"dFdy(${1:value})$2"
		],
		"description": "genType dFdy(genType p);\ngenType dFdyCoarse(genType p);\ngenType dFdyFine(genType p);\n\np:关于y的偏导数的参数\n\n\n"
	},

	"exp e^x": {
		"prefix": "exp",
		"body": [
			"exp(${1:value})$2"
		],
		"description": "genType exp(genType x);\n\n返回自然指数e的x次幂\n\n"
	},

	"exp2 2^x": {
		"prefix": "exp2",
		"body": [
			"exp2(${1:value})$2"
		],
		"description": "genType exp2(genType x);\n\n返回2的x次幂\n\n"
	},

	"floor 向下取整": {
		"prefix": "floor",
		"body": [
			"floor(${1:value})$2"
		],
		"description": "genType floor(genType x);\ngenDType floor(genDType x);\n\n返回x向下取整的值(小于等于x的整数)\n\n"
	},

	"fma 融合乘加": {
		"prefix": "fma",
		"body": [
			"fma(${1:a}, ${2:b}, ${3:c})$4"
		],
		"description": "genType fma(genType a,genType b,genType c);\ngenDType fma(genDType a,genDType b,genDType c);\n\n返回a * b + c\n\n"
	},

	"fract 取小数": {
		"prefix": "fract",
		"body": [
			"fract(${1:value})$2"
		],
		"description": "genType fract(genType x);\ngenDType fract(genDType x);\n\n求x的小数部分,结果在0到1之间\n相当于 x - floor(x)\n\n"
	},

	"fwidth": {
		"prefix": "fwidth",
		"body": [
			"fwidth(${1:value})$2"
		],
		"description": "genType fwidth(genType p);\ngenType fwidthCoarse(genType p);\ngenType fwidthFine(genType p);\n\n仅在片段着色器中可用\n\n"
	},

	"inversesqrt  平方根倒数": {
		"prefix": "inversesqrt",
		"body": [
			"inversesqrt(${1:value})$2"
		],
		"description": "genType inversesqrt(genType x);\ngenDType inversesqrt(genDType x);\n\n返回1/sqrt(x)\n\n"
	},

	"isinf 判断无穷": {
		"prefix": "isinf",
		"body": [
			"isinf(${1:value})$2"
		],
		"description": "genBType isinf(genType x);\ngenBType isinf(genDType x);\n\n如果x为正或负浮点无穷则返回true,否则返回false\n\n"
	},

	"isnan 判断非数字": {
		"prefix": "isnan",
		"body": [
			"isnan(${1:value})$2"
		],
		"description": "genBType isnan(genType x);\ngenBType isnan(genDType x);\n\n如果x为NaN(Not a Number 非数字)则返回true,否则返回false\n\n"
	},

	"log": {
		"prefix": "log",
		"body": [
			"log(${1:value})$2"
		],
		"description": "genType log(genType x);\n\n返回x的自然对数,返回值y满足x=e^y\n\n"
	},

	"log2": {
		"prefix": "log2",
		"body": [
			"log2(${1:value})$2"
		],
		"description": "genType log2(genType x);\n\n返回以2为底x的对数,返回值y满足x=2^y\n\n"
	},

	"max 取大": {
		"prefix": "max",
		"body": [
			"max(${1:x}, ${2:y})$3"
		],
		"description": "genType max(genType x,genType y);\ngenType max(genType x,float y);\ngenDType max(genDType x,genDType y);\ngenDType max(genDType x,double y);\ngenIType max(genIType x,genIType y);\ngenIType max(genIType x,int y);\ngenUType max(genUType x,genUType y);\ngenUType max(genUType x,uint y);\n\n返回x和y之间大的那个\n\n"
	},

	"min 取小": {
		"prefix": "min",
		"body": [
			"min(${1:x}, ${2:y})$3"
		],
		"description": "genType min(genType x,genType y);\ngenType min(genType x,float y);\ngenDType min(genDType x,genDType y);\ngenDType min(genDType x,double y);\ngenIType min(genIType x,genIType y);\ngenIType min(genIType x,int y);\ngenUType min(genUType x,genUType y);\ngenUType min(genUType x,uint y);\n\n返回x和y之间小的那个\n\n"
	},

	"mix 线性插值": {
		"prefix": "mix",
		"body": [
			"mix(${1:x}, ${2:y}, ${3:a})$4"
		],
		"description": "genType mix(genType x,genType y,genType a);\ngenType mix(genType x,genType y,float a);\ngenDType mix(genDType x,genDType y,genDType a);\ngenDType mix(genDType x,genDType y,double a);\ngenType mix(genType x,genType y,genBType a);\ngenDType mix(genDType x,genDType y,genBType a);\ngenIType mix(genIType x,genIType y,genBType a);\ngenUType mix(genUType x,genUType y,genBType a);\ngenBType mix(genBType x,genBType y,genBType a);\n\nx:插值范围的起点\ny:插值范围的终点\na:x和y之间进行插值的值\n\n\n返回(1-a)*x + a*y\n\n"
	},

	"mod 取余": {
		"prefix": "mod",
		"body": [
			"mod(${1:x}, ${2:y})$3"
		],
		"description": "genType mod(genType x,float y);\ngenType mod(genType x,genType y);\ngenDType mod(genDType x,double y);\ngenDType mod(genDType x,genDType y);\n\n返回x-y*floor(x/y),即x/y的余数\n\n"
	},

	"modf 浮点数拆分为整数和小数": {
		"prefix": "modf",
		"body": [
			"modf(${1:x}, out ${2:i})$3"
		],
		"description": "genType modf(genType x,out genType i);\ngenDType modf(genDType x,out genDType i);\n\nx:被拆分的浮点数\ni:存储整数部分\n\n\n拆分浮点数x,返回小数部分，整数部分(转化为浮点数)在输出参数i中返回\n\n"
	},

	"noise 噪声": {
		"prefix": "noise",
		"body": [
			"noise${1:1}(${2:value})$3"
		],
		"description": "float noise1(genType x);\nvec2 noise2(genType x);\nvec3 noise3(genType x);\nvec4 noise4(genType x);\n\n根据输入值x返回噪声值(向量或标量)\n噪声函数是一种随机函数,可用于增加视觉复杂性\n噪声函数看起来是随机的,但不是真正的随机,它们被定义为具有以下特征:\n\n· 返回值始终在[-1.0, 1.0]之间,并且至少覆盖[-0.6, 0.6],具有类高斯分布\n· 返回值的总体平均值为0.0\n· 可复现,特定的x始终产生相同的返回值\n· 无论域如何旋转,它都具有相同的统计特征\n· 无论域如何变换,它都具有相同的统计特征\n· 通常在变换后给出不同的结果\n· 空间频率集中在0.5 ~ 1.0之间\n· 在任何地方都是C1连续的(一阶导数是连续的)\n\n"
	},

	"pow 幂运算": {
		"prefix": "pow",
		"body": [
			"pow(${1:x}, ${2:y})$3"
		],
		"description": "genType pow(genType x, genType y);\n\n返回x^y\n\n"
	},

	"round 近似整数": {
		"prefix": "round",
		"body": [
			"round(${1:value})$2"
		],
		"description": "genType round(genType x);\ngenDType round(genDType x);\n\n返回最接近x的整数\n\n"
	},

	"roundEven 近似偶数": {
		"prefix": "roundEven",
		"body": [
			"roundEven(${1:value})$2"
		],
		"description": "genType roundEven(genType x);\ngenDType roundEven(genDType x);\n\n返回最接近x的偶数\n\n"
	},

	"sign 取符号": {
		"prefix": "sign",
		"body": [
			"sign(${1:value})$2"
		],
		"description": "genType sign(genType x);\ngenIType sign(genIType x);\ngenDType sign(genDType x);\n\n返回x的符号:\n· x = 0,返回 0.0\n· x < 0,返回 -1.0\n· x > 0,返回 1.0\n\n"
	},

	"smoothstep 平滑插值": {
		"prefix": "smoothstep",
		"body": [
			"smoothstep(${1:edge0}, ${2:edge1}, ${3:x})$4"
		],
		"description": "genType smoothstep(genType edge0,genType edge1,genType x);\ngenType smoothstep(float edge0,float edge1,genType x);\ngenDType smoothstep(genDType edge0,genDType edge1,genDType x);\ngenDType smoothstep(double edge0,double edge1,genDType x);\n\nedge0:Hermite函数的下边缘\ndege1:Hermite函数的上边缘\nx:插值的源值\n\n\n当edge0<x<edge1时,在0~1之间执行平滑Hermite插值\n\ngenType t;  /* Or genDType t; */\nt = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\nreturn t * t * (3.0 - 2.0 * t);\n\n"
	},

	"sqrt 平方根": {
		"prefix": "sqrt",
		"body": [
			"sqrt(${1:value})$2"
		],
		"description": "genType sqrt(genType x);\ngenDType sqrt(genDType x);\n\n返回x的平方根\n\n"
	},

	"step 阶跃": {
		"prefix": "step",
		"body": [
			"step(${1:edge}, ${2:x})$3"
		],
		"description": "genType step(genType edge,genType x);\ngenType step(float edge,genType x);\ngenDType step(genDType edge,genDType x);\ngenDType step(double edge,genDType x);\n\nedge:阶跃边缘值\nx:阶跃检测值\n\n\n当x > edge时,返回1.0;\n当x < edge时,返回0.0\n\n"
	},

	"trunc 向0取整": {
		"prefix": "trunc",
		"body": [
			"trunc(${1:value})$2"
		],
		"description": "genType trunc(genType x);\ngenDType trunc(genDType x);\n\n返回最接近x并且绝对值不大于x的绝对值的整数\n\n"
	},

	//Floating-Point 浮点

	"floatBitsToInt 浮点转整形": {
		"prefix": "floatBitsToInt",
		"body": [
			"floatBitsToInt(${1:value})$2"
		],
		"description": "genIType floatBitsToInt(genType x);\n\n返回整形\n\n"
	},

	"floatBitsToUint 浮点转无符号整形": {
		"prefix": "floatBitsToUint",
		"body": [
			"floatBitsToUint(${1:value})$2"
		],
		"description": "genIType floatBitsToUint(genType x);\n\n返回无符号整形\n\n"
	},

	"frexp 拆分浮点数": {
		"prefix": "frexp",
		"body": [
			"frexp(${1:x}, out ${2:exp})$3"
		],
		"description": "genType frexp(genType x,out genIType exp);\ngenDType frexp(genDType x,out genIType exp);\n\n把浮点数分解为尾数和指数,返回尾数\n指数返回到exp\n\n\ne.g 1024.0的尾数为0.5,指数为11\n(1024.0 = 0.5 * 2^11)\n\n"
	},

	"intBitsToFloat 整形转化为浮点": {
		"prefix": "intBitsToFloat",
		"body": [
			"intBitsToFloat(${1:value})$2"
		],
		"description": "genType intBitsToFloat(genIType x);\n\n返回浮点数\n\n"
	},

	"uintBitsToFloat 无符号整型转化为浮点": {
		"prefix": "uintBitsToFloat",
		"body": [
			"uintBitsToFloat(${1:value})$2"
		],
		"description": "genType uintBitsToFloat(genUType x);\n\n返回浮点数\n\n"
	},

	"ldexp 组装浮点数": {
		"prefix": "ldexp",
		"body": [
			"ldexp(${1:x}, ${2:exp})$3"
		],
		"description": "genType ldexp(genType x,genIType exp);\ngenDType ldexp(genDType x,genIType exp);\n\n根据尾数x和指数exp组装浮点数\n返回x * 2^exp\n\n"
	},

	"packDouble2x32 组装双精度浮点数": {
		"prefix": "packDouble2x32",
		"body": [
			"packDouble2x32(${1:v})$2"
		],
		"description": "double packDouble2x32(uvec2 v);\n\nv:无符号整形二维向量\n\n\n将v的分量组装成一个64位的双精度浮点值\nv[0]指定结果的32个最低有效位,v[1]指定结果的32个最高有效位\n\n"
	},

	"packHalf2x16 组装无符号整数": {
		"prefix": "packHalf2x16",
		"body": [
			"packHalf2x16(${1:v})$2"
		],
		"description": "uint packHalf2x16(vec2 v);\n\nv:浮点型二维向量\n\n\n返回一个无符号整数\n将浮点向量分量转换为opengl规范的16位浮点表示,然后将这两个16位整数打包成一个32位无符号整数\nv[0]指定结果的16个最低有效位\nv[1]指定结果的16个最高有效位\n\n"
	},

	"packUnorm2x16": {
		"prefix": "packUnorm2x16",
		"body": [
			"packUnorm2x16(${1:v})$2"
		],
		"description": "uint packUnorm2x16(vec2 v);\n\nv:浮点型二维向量\n\n\n返回一个无符号整数\n将v的每个分量转换为16位整数,然后将结果打包成一个32位无符号整数\n对于v的每个分量c,满足下式:\nround(clamp(c, 0.0, 1.0) * 65535.0)\n\n"
	},

	"packUnorm4x8": {
		"prefix": "packUnorm4x8",
		"body": [
			"packUnorm4x8(${1:v})$2"
		],
		"description": "uint packUnorm4x8(vec4 v);\n\nv:浮点型四维向量\n\n\n返回一个无符号整数\n将v的每个分量转换为8位整数,然后将结果打包成一个32位无符号整数\n对于v的每个分量c,满足下式:\nround(clamp(c, -1.0, 1.0) * 32767.0)\n\n"
	},

	"packSnorm2x16": {
		"prefix": "packSnorm2x16",
		"body": [
			"packSnorm2x16(${1:v})$2"
		],
		"description": "uint packSnorm2x16(vec2 v);\n\nv:浮点型二维向量\n\n\n返回一个有符号整数\n将v的每个分量转换为16位整数,然后将结果打包成一个32位无符号整数\n对于v的每个分量c,满足下式:\nround(clamp(c, 0.0, 1.0) * 255.0)\n\n"
	},

	"packSnorm4x8": {
		"prefix": "packSnorm4x8",
		"body": [
			"packSnorm4x8(${1:v})$2"
		],
		"description": "uint packSnorm4x8(vec4 v);\n\nv:浮点型四维向量\n\n\n返回一个有符号整数\n将v的每个分量转换为8位整数,然后将结果打包成一个32位无符号整数\n对于v的每个分量c,满足下式:\nround(clamp(c, -1.0, 1.0) * 127.0)\n\n"
	},

	"unpackDouble2x32": {
		"prefix": "unpackDouble2x32",
		"body": [
			"unpackDouble2x32(${1:d})$2"
		],
		"description": "uvec2 unpackDouble2x32(double d);\n\nd:双精度浮点值\n\n\n返回无符号整形二维向量\n返回向量的第一个分量包含d的32个最低有效位\n第二个分量包含d的32个最高有效位\n\n"
	},

	"unpackHalf2x16": {
		"prefix": "unpackHalf2x16",
		"body": [
			"unpackHalf2x16(${1:v})$2"
		],
		"description": "vec2 unpackHalf2x16(uint v);\n\nv:32位无符号整型,其中包含要解包的两个16位浮点值\n\n\n返回浮点型二维向量\n将32位无符号整数v解包为一对16位值,根据opengl规范解释为16位浮点数然后转换为32位浮点值\n向量的第一个分量是v的16个最低有效位\n第二个分量是v的16个最高有效位\n\n"
	},

	"unpackUnorm2x16": {
		"prefix": "unpackUnorm2x16",
		"body": [
			"unpackUnorm2x16(${1:p})$2"
		],
		"description": "vec2 unpackUnorm2x16(uint p);\n\np:无符号整形\n\n\n返回浮点型二维向量\n将p解包为一对16位无符号整数,然后将每个分量转换为归一化的浮点值\n解压缩定点值f执行的转换如下:\nf / 65535.0\n\n"
	},

	"unpackUnorm4x8": {
		"prefix": "unpackUnorm4x8",
		"body": [
			"unpackUnorm4x8(${1:p})$2"
		],
		"description": "vec4 unpackUnorm4x8(uint p);\n\np:无符号整形\n\n\n返回浮点型四维向量\n将p解包为四个8位无符号整数,然后将每个分量转换为归一化的浮点值\n解压缩定点值f执行的转换如下:\nf / 255.0\n\n"
	},

	"unpackSnorm2x16": {
		"prefix": "unpackSnorm2x16",
		"body": [
			"unpackSnorm2x16(${1:p})$2"
		],
		"description": "vec2 unpackUnorm2x16(uint p);\n\np:无符号整形\n\n\n返回浮点型二维向量\n将p解包为一对16位无符号整数,然后将每个分量转换为归一化的浮点值\n解压缩定点值f执行的转换如下:\nclamp(f / 32727.0, -1.0, 1.0)\n\n"
	},

	"unpackSnorm4x8": {
		"prefix": "unpackSnorm4x8",
		"body": [
			"unpackSnorm4x8(${1:p})$2"
		],
		"description": "vec2 unpackUnorm2x16(uint p);\n\np:无符号整形\n\n\n返回浮点型二维向量\n将p解包为四个8位有符号整数,然后将每个分量转换为归一化的浮点值\n解压缩定点值f执行的转换如下:\nclamp(f / 127.0, -1.0, 1.0)\n\n"
	},

	//Built-In Variables 内建变量

	"gl_ClipDistance": {
		"prefix": "gl_ClipDistance",
		"body": [
			"gl_ClipDistance"
		],
		"description": "in float gl_ClipDistance[];\n为顶点裁剪提供了向前兼容的机制\n\ngl_ClipDistance是gl_PerVertex命名块的成员之一:\n\tout gl_PerVertex {\n\t   vec4 gl_Position;\n\t   float gl_PointSize;\n\t   float gl_ClipDistance[];\n\t};\n\n"
	},

	"gl_CullDistance": {
		"prefix": "gl_CullDistance",
		"body": [
			"gl_CullDistance"
		],
		"description": "in float gl_CullDistance[];\n提供了一种控制用户剔除的机制\n\ngl_CullDistance是gl_PerVertex命名块的成员之一:\n\tout gl_PerVertex {\n\t   vec4 gl_Position;\n\t   float gl_PointSize;\n\t   float gl_ClipDistance[];\n\t   float gl_CullDistance[];\n\t};\n\n"
	},

	"gl_FragCoord": {
		"prefix": "gl_FragCoord",
		"body": [
			"gl_FragCoord"
		],
		"description": "in vec4 gl_FragCoord;\n包含当前片段的窗口相对坐标\n\n"
	},

	"gl_FragDepth": {
		"prefix": "gl_FragDepth",
		"body": [
			"gl_FragDepth"
		],
		"description": "out float gl_FragDepth;\n为当前片段建立深度值\n\n"
	},

	"gl_FrontFacing": {
		"prefix": "gl_FrontFacing",
		"body": [
			"gl_FrontFacing"
		],
		"description": "in bool gl_FrontFacing;\n指示图元是正面还是背面\n\n"
	},

	"gl_GlobalInvocationID": {
		"prefix": "gl_GlobalInvocationID",
		"body": [
			"gl_GlobalInvocationID"
		],
		"description": "in uvec3 gl_GlobalInvocationID;\n包含计算着色器当前正在操作的工作项的全局索引\n\n"
	},

	"gl_HelperInvocation": {
		"prefix": "gl_HelperInvocation",
		"body": [
			"gl_HelperInvocation"
		],
		"description": "in bool gl_HelperInvocation;\n指示片段着色器是否是辅助调用\n\n"
	},

	"gl_InstanceID": {
		"prefix": "gl_InstanceID",
		"body": [
			"gl_InstanceID"
		],
		"description": "in int gl_InstanceID;\n包含实例化绘制命令中当前图元的索引\n\n"
	},

	"gl_InvocationID": {
		"prefix": "gl_InvocationID",
		"body": [
			"gl_InvocationID"
		],
		"description": "in int gl_InvocationID;\n包含当前着色器的调用索引\n\n"
	},

	"gl_Layer": {
		"prefix": "gl_Layer",
		"body": [
			"gl_Layer"
		],
		"description": "几何着色器:   out int gl_Layer;\n片段着色器:   in int gl_Layer;\n包含多层帧缓冲附件的选定层\n\n"
	},

	"gl_LocalInvocationID": {
		"prefix": "gl_LocalInvocationID",
		"body": [
			"gl_LocalInvocationID"
		],
		"description": "in uvec3 gl_LocalInvocationID;\n包含计算着色器当前正在操作的工作项的索引\n\n"
	},

	"gl_LocalInvocationIndex": {
		"prefix": "gl_LocalInvocationIndex",
		"body": [
			"gl_LocalInvocationIndex"
		],
		"description": "in uint gl_LocalInvocationIndex;\n包含计算着色器当前正在操作的工作项的本地线性索引\n\n"
	},

	"gl_NumSamples": {
		"prefix": "gl_NumSamples",
		"body": [
			"gl_NumSamples"
		],
		"description": "in bool gl_NumSamples;\n包含帧缓冲区中的样本总数\n\n"
	},

	"gl_NumWorkGroups": {
		"prefix": "gl_NumWorkGroups",
		"body": [
			"gl_NumWorkGroups"
		],
		"description": "in uvec3 gl_NumWorkGroups;\n包含已分配到计算着色器的工作组数\n\n"
	},

	"gl_PatchVerticesIn": {
		"prefix": "gl_PatchVerticesIn",
		"body": [
			"gl_PatchVerticesIn"
		],
		"description": "in int gl_PatchVerticesIn;\n包含当前补丁中的顶点数\n\n"
	},

	"gl_PointCoord": {
		"prefix": "gl_PointCoord",
		"body": [
			"gl_PointCoord"
		],
		"description": "in vec2 gl_PointCoord;\n包含一个点内片段的坐标\n\n"
	},

	"gl_PointSize": {
		"prefix": "gl_PointSize",
		"body": [
			"gl_PointSize"
		],
		"description": "gl_PointSize是gl_PerVertex命名块的成员:\n\tout gl_PerVertex {\n\t   vec4 gl_Position;\n\t   float gl_PointSize;\n\t   float gl_ClipDistance[];\n\t};\n包含光栅化点的大小,以像素为单位\n\n"
	},

	"gl_Position": {
		"prefix": "gl_Position",
		"body": [
			"gl_Position"
		],
		"description": "gl_Position是gl_PerVertex命名块的成员:\n\tout gl_PerVertex {\n\t   vec4 gl_Position;\n\t   float gl_PointSize;\n\t   float gl_ClipDistance[];\n\t};\n包含当前顶点的位置\n\n"
	},

	"gl_PrimitiveID": {
		"prefix": "gl_PrimitiveID",
		"body": [
			"gl_PrimitiveID"
		],
		"description": "tessellation control, tessellation evaluation 和 片段着色器中:   in int gl_PrimitiveID;\n几何着色器中:   out int gl_PrimitiveID\n包含当前片元的索引\n\n"
	},

	"gl_PrimitiveIDIn": {
		"prefix": "gl_PrimitiveIDIn",
		"body": [
			"gl_PrimitiveIDIn"
		],
		"description": "in int gl_PrimitiveIDIn;\n包含当前片元的索引\n\n"
	},

	"gl_SampleID": {
		"prefix": "gl_SampleID",
		"body": [
			"gl_SampleID"
		],
		"description": "in int gl_SampleID;\n包含当前正在处理的样本的索引\n\n"
	},

	"gl_SampleMask": {
		"prefix": "gl_SampleMask",
		"body": [
			"gl_SampleMask"
		],
		"description": "out int gl_SampleMask[];\n指定当前片段的样本覆盖掩码\n\n"
	},

	"gl_SampleMaskIn": {
		"prefix": "gl_SampleMaskIn",
		"body": [
			"gl_SampleMaskIn"
		],
		"description": "in int gl_SampleMaskIn[];\n包含当前片段的计算样本覆盖掩码\n\n"
	},

	"gl_SamplePosition": {
		"prefix": "gl_SamplePosition",
		"body": [
			"gl_SamplePosition"
		],
		"description": "in vec2 gl_SamplePosition;\n包含当前片段中当前样本的位置\n\n"
	},

	"gl_TessCoord": {
		"prefix": "gl_TessCoord",
		"body": [
			"gl_TessCoord"
		],
		"description": "in vec3 gl_TessCoord;\n包含当前补丁中顶点的坐标\n\n"
	},

	"gl_TessLevelInner": {
		"prefix": "gl_TessLevelInner",
		"body": [
			"gl_TessLevelInner"
		],
		"description": "In tessellation control shaders:   out float gl_TessLevelInner[2];\nIn tessellation evaluation shaders:   in float gl_TessLevelInner[2];\n包含当前补丁的内部细分级别\n\n"
	},

	"gl_TessLevelOuter": {
		"prefix": "gl_TessLevelOuter",
		"body": [
			"gl_TessLevelOuter"
		],
		"description": "In tessellation control shaders:   out float gl_TessLevelOuter[4];\nIn tessellation evaluation shaders:   in float gl_TessLevelOuter[4];\n包含当前补丁的外部细分级别\n\n"
	},

	"gl_VertexID": {
		"prefix": "gl_VertexID",
		"body": [
			"gl_VertexID"
		],
		"description": "in int gl_VertexID;\n包含当前顶点的索引\n\n"
	},

	"gl_ViewportIndex": {
		"prefix": "gl_ViewportIndex",
		"body": [
			"gl_ViewportIndex"
		],
		"description": "在几何着色器中:   out int gl_ViewportIndex;\n在片段着色器中:   in int gl_ViewportIndex;\n包含要在视口转换和剪裁中使用的视口的索引\n\n"
	},

	"gl_WorkGroupID": {
		"prefix": "gl_WorkGroupID",
		"body": [
			"gl_WorkGroupID"
		],
		"description": "in uvec3 gl_WorkGroupID;\n包含计算着色器当前正在操作的工作组的索引\n\n"
	},

	"gl_WorkGroupSize": {
		"prefix": "gl_WorkGroupSize",
		"body": [
			"gl_WorkGroupSize"
		],
		"description": "const uvec3 gl_WorkGroupSize;\n包含计算着色器操作的工作组的大小\n\n"
	},

	"gl_FragColor": {
		"prefix": "gl_FragColor",
		"body": "gl_FragColor",
		"description": "mediump vec4 gl_FragColor;\n\nThe built-in variable gl_FragColor is used by the fragment shader to hand over the color of the fragment to the OpenGL ES 2.0 pipeline. The variable is pre-declared as shown above that way the variable can be used in the fragment shader for an assignment without prior declaration.\nThe values of the color vector are interpreted in the RGBA color space.\nThe assignment of values to this variable is mandatory for the fragment shader."
	},

	//内建常量

	"gl_MaxVertexAttribs": {
		"prefix": "gl_MaxVertexAttribs",
		"body": [
			"gl_MaxVertexAttribs"
		],
		"description": "const mediump int gl_MaxVertexAttribs = 16;\n可用的顶点输入变量(GLSL 1.3之前为attribute变量)的最大数量\n\n"
	},

	"gl_MaxVertexUniformVectors": {
		"prefix": "gl_MaxVertexUniformVectors",
		"body": [
			"gl_MaxVertexUniformVectors"
		],
		"description": "const mediump int gl_MaxVertexUniformVectors = 256;\n可用的vec4统一变量(uniform变量)的最大数量  需要#version 410及以上\n\n"
	},

	"gl_MaxVertexOutputVectors": {
		"prefix": "gl_MaxVertexOutputVectors",
		"body": [
			"gl_MaxVertexOutputVectors"
		],
		"description": "const mediump int gl_MaxVertexOutputVectors = 16;\n可用的顶点输出变量(GLSL 1.3之前为varying变量)的最大数量  需要#version 410及以上\n\n"
	},

	"gl_MaxVertexTextureImageUnits": {
		"prefix": "gl_MaxVertexTextureImageUnits",
		"body": [
			"gl_MaxVertexTextureImageUnits"
		],
		"description": "const mediump int gl_MaxVertexTextureImageUnits = 16;\n可用的纹理的最大数量\n\n"
	},

	"gl_MaxCombinedTextureImageUnits": {
		"prefix": "gl_MaxCombinedTextureImageUnits",
		"body": [
			"gl_MaxCombinedTextureImageUnits"
		],
		"description": "const mediump int gl_MaxCombinedTextureImageUnits = 32;\nvs和fs中可用的纹理的最大数量的总和\n\n"
	},

	"gl_MaxFragmentInputVectors": {
		"prefix": "gl_MaxFragmentInputVectors",
		"body": [
			"gl_MaxFragmentInputVectors"
		],
		"description": "const mediump int gl_MaxFragmentInputVectors = 15;\n片元输入变量(GLSL 1.3之前为varying)变量的最大数量  需要#version 410及以上\n\n"
	},

	"gl_MaxTextureImageUnits": {
		"prefix": "gl_MaxTextureImageUnits",
		"body": [
			"gl_MaxTextureImageUnits"
		],
		"description": "const mediump int gl_MaxTextureImageUnits = 16;\n可用的纹理的最大数量\n\n"
	},

	"gl_MaxFragmentUniformVectors": {
		"prefix": "gl_MaxFragmentUniformVectors",
		"body": [
			"gl_MaxFragmentUniformVectors"
		],
		"description": "const mediump int gl_MaxFragmentUniformVectors = 224;\n可用的vec4统一变量(uniform变量)的最大数量  需要#version 410及以上\n\n"
	},

	"gl_MaxDrawBuffers": {
		"prefix": "gl_MaxDrawBuffers",
		"body": [
			"gl_MaxDrawBuffers"
		],
		"description": "const mediump int gl_MaxDrawBuffers = 4;\n多重渲染目标(MRT)的最大支持数量。\n\n"
	},

	"gl_MinProgramTexelOffset": {
		"prefix": "gl_MinProgramTexelOffset",
		"body": [
			"gl_MinProgramTexelOffset"
		],
		"description": "const mediump int gl_MinProgramTexelOffset = -8;\n内建ESSL函数texture*Offset偏移参数迟滞的最小偏移值  需要#version 410及以上\n\n"
	},

	"gl_MaxProgramTexelOffset": {
		"prefix": "gl_MaxProgramTexelOffset",
		"body": [
			"gl_MaxProgramTexelOffset"
		],
		"description": "const mediump int gl_MaxProgramTexelOffset = 7;\n内建ESSL函数texture*Offset偏移参数迟滞的最大偏移值  需要#version 410及以上\n\n"
	},

	//Vector 向量

	"cross 叉乘": {
		"prefix": "cross",
		"body": [
			"cross(${1:v1}, ${2:v2})$3"
		],
		"description": "vec3 cross(vec3 x,vec3 y);\ndvec3 cross(dvec3 x,dvec3 y);\n\n返回x和y的叉积\n\n"
	},

	"distance 距离": {
		"prefix": "distance",
		"body": [
			"distance(${1:p0}, ${2:p1})$3"
		],
		"description": "float distance(genType p0,genType p1);\ndouble distance(genDType p0,genDType p1);\n\n返回p0和p1两点之间的距离\n\n"
	},

	"dot 点乘": {
		"prefix": "dot",
		"body": [
			"dot(${1:v1}, ${2:v2})$3"
		],
		"description": "float dot(genType x,genType y);\ndouble dot(genDType x,genDType y);\n\n返回x和y的点积\n\n"
	},

	"equal 判断相等": {
		"prefix": "equal",
		"body": [
			"equal(${1:v1}, ${2:v2})$3"
		],
		"description": "bvec equal(vec x,vec y);\nbvec equal(ivec x,ivec y);\nbvec equal(uvec x,uvec y);\n\n返回x与y逐分量比较是否相等的bool向量\n\n"
	},

	"faceforward 面向视图方向的曲面法向量": {
		"prefix": "faceforward",
		"body": [
			"faceforward(${1:N}, ${2:I}, ${3:Nref})$4"
		],
		"description": "genType faceforward(genType N,genType I,genType Nref);\ngenDType faceforward(genDType N,genDType I,genDType Nref);\n\nN:要定向的向量\nI:事件向量\nNref:参考向量\n\n\n如果dot(Nerf, I) < 0,返回N,否则返回-N\n\n"
	},

	"length 计算长度": {
		"prefix": "length",
		"body": [
			"length(${1:x})$2"
		],
		"description": "float length(genType x);\ndouble length(genDType x);\n\nx:要计算长度的向量\n\n\n返回向量的长度\n\n"
	},

	"normalize 归一化": {
		"prefix": "normalize",
		"body": [
			"normalize(${1:v})$2"
		],
		"description": "genType normalize(genType v);\ngenDType normalize(genDType v);\n\n返回v的归一化结果\n\n"
	},

	"notEqual 判断不相等": {
		"prefix": "notEqual",
		"body": [
			"notEqual(${1:v1}, ${2:v2})$3"
		],
		"description": "bvec notEqual(vec x,vec y);\nbvec notEqual(ivec x,ivec y);\nbvec notEqual(uvec x,uvec y);\n\n返回x与y逐分量比较是否不相等的bool向量\n\n"
	},

	"reflect 计算反射向量": {
		"prefix": "reflect",
		"body": [
			"reflect(${1:I}, ${2:N})$3"
		],
		"description": "genType reflect(genType I,genType N);\ngenDType reflect(genDType I,genDType N);\n\nI:入射向量\nN:归一化的表面法线向量\n\n\n计算入射向量的反射向量\nI - 2.0 * dot(N, I) * N\n\n"
	},

	"refract": {
		"prefix": "refract",
		"body": [
			"refract(${1:I}, ${2:N}, ${3:eta})$4"
		],
		"description": "genType refract(genType I,genType N,float eta);\ngenDType refract(genDType I,genDType N,float eta);\n\nI:归一化的入射向量\nN:归一化的表面法线向量\neta:折射率的比率\n\n\n返回折射向量R:\n    k = 1.0 - eta * eta * (1.0 - dot(N, I) * dot(N, I));\n    if (k < 0.0)\n        R = genType(0.0);       // or genDType(0.0)\n    else\n        R = eta * I - (eta * dot(N, I) + sqrt(k)) * N;\n\n"
	},

	//Component Comparison 组件比较

	"all": {
		"prefix": "all",
		"body": [
			"all(${1:bv})$2"
		],
		"description": "bool all(bvec x);\n\n如果bool向量x的各分量全为true,返回true,否则返回false\n\n"
	},

	"any": {
		"prefix": "any",
		"body": [
			"any(${1:bv})$2"
		],
		"description": "bool any(bvec x);\n\n如果bool向量x的任意分量为true,返回true,否则返回false\n\n"
	},

	"greaterThan": {
		"prefix": "greaterThan",
		"body": [
			"greaterThan(${1:v1}, ${2:v2})$3"
		],
		"description": "bvec greaterThan(vec x,vec y);\nbvec greaterThan(ivec x,ivec y);\nbvec greaterThan(uvec x,uvec y);\n\n返回x与y逐分量比较x[i] > y[i]的bool向量\n\n"
	},

	"greaterThanEqual": {
		"prefix": "greaterThanEqual",
		"body": [
			"greaterThanEqual(${1:v1}, ${2:v2})$3"
		],
		"description": "bvec greaterThanEqual(vec x,vec y);\nbvec greaterThanEqual(ivec x,ivec y);\nbvec greaterThanEqual(uvec x,uvec y);\n\n返回x与y逐分量比较x[i] >= y[i]的bool向量\n\n"
	},

	"lessThan": {
		"prefix": "lessThan",
		"body": [
			"lessThan(${1:v1}, ${2:v2})$3"
		],
		"description": "bvec lessThan(vec x,vec y);\nbvec lessThan(ivec x,ivec y);\nbvec lessThan(uvec x,uvec y);\n\n返回x与y逐分量比较x[i] < y[i]的bool向量\n\n"
	},

	"lessThanEqual": {
		"prefix": "lessThanEqual",
		"body": [
			"lessThanEqual(${1:v1}, ${2:v2})$3"
		],
		"description": "bvec lessThanEqual(vec x,vec y);\nbvec lessThanEqual(ivec x,ivec y);\nbvec lessThanEqual(uvec x,uvec y);\n\n返回x与y逐分量比较x[i] <= y[i]的bool向量\n\n"
	},

	"not": {
		"prefix": "not",
		"body": [
			"not(${1:bv})$2"
		],
		"description": "bvec not(bvec x);\n\n反转bool向量x的各分量\n\n"
	},

	//Geometry Shader 几何着色器

	"EmitStreamVertex": {
		"prefix": "EmitStreamVertex",
		"body": [
			"EmitStreamVertex(${1:stream})$2"
		],
		"description": "void EmitStreamVertex(int stream);\n\nstream:将在其上发射顶点的流\n\n\n将顶点发射到指定流\n\n"
	},

	"EmitVertex": {
		"prefix": "EmitVertex",
		"body": [
			"EmitVertex()$1"
		],
		"description": "void EmitVertex(void);\n\n向第一个顶点流发射一个顶点\n将输出变量的当前值发送到第一个(也可能是唯一一个)图元流上的当前输出图元\n相当于调用EmitStreamVertex(0)\n\n"
	},

	"EndPrimitive": {
		"prefix": "EndPrimitive",
		"body": [
			"EndPrimitive()$1"
		],
		"description": "void EndPrimitive(void);\n\n在第一个顶点流上完成当前输出图元\n在第一个(也可能是唯一一个)顶点流上完成当前输出图元并开始一个新的.不发射顶点\n相当于调用EndStreamPrimitive(0)\n\n"
	},

	"EndStreamPrimitive": {
		"prefix": "EndStreamPrimitive",
		"body": [
			"EndStreamPrimitive(${1:stream})$2"
		],
		"description": "void EndStreamPrimitive(int stream);\n\n在指定流上完成当前输出图元,不发射顶点\n\n"
	},

	//Texture Sampling 纹理采样

	"interpolateAtCentroid 质心采样": {
		"prefix": "interpolateAtCentroid",
		"body": [
			"interpolateAtCentroid(${1:interpolant})$2"
		],
		"description": "float interpolateAtCentroid(float interpolant);\nvec2 interpolateAtCentroid(vec2 interpolant);\nvec3 interpolateAtCentroid(vec3 interpolant);\nvec4 interpolateAtCentroid(vec4 interpolant);\n\ninterpolant:要在像素质心处采样的插值\n\n\n在像素的质心处对变化采样\n返回在像素和正在处理的图元内部的某个位置采样的输入变化插值的值\n如果使用质心限定符声明,则获得的值将是分配给输入变量的值\n\n"
	},

	"interpolateAtOffset 质心偏移采样": {
		"prefix": "interpolateAtOffset",
		"body": [
			"interpolateAtOffset(${1:interpolant}, ${2:offset})$3"
		],
		"description": "float interpolateAtOffset(float interpolant,vec2 offset);\nvec2 interpolateAtOffset(vec2 interpolant,vec2 offset);\nvec3 interpolateAtOffset(vec3 interpolant,vec2 offset);\nvec4 interpolateAtOffset(vec4 interpolant,vec2 offset);\n\ninterpolant:要在指定偏移处采样的插值\noffset:对插值采样的像素中心的偏移量\n\n\n返回在偏移指定的像素中心的偏移处采样的输入变化插值的值\noffset的两个浮点分量分别给出像素中心在x和y方向上的偏移量\n(0,0)的偏移量标识像素中心\n\n"
	},

	"interpolateAtSample 指定样本采样": {
		"prefix": "interpolateAtSample",
		"body": [
			"interpolateAtSample(${1:interpolant}, ${2:sample})$3"
		],
		"description": "float interpolateAtSample(float interpolant,int sample);\nvec2 interpolateAtSample(vec2 interpolant,int sample);\nvec3 interpolateAtSample(vec3 interpolant,int sample);\nvec4 interpolateAtSample(vec4 interpolant,int sample);\n\ninterpolant:要在sample的位置采样的插值\nsample:其位置将用于采样插值的样本的索引\n\n\n返回在样本编号sample的位置采样的输入变化插值的值\n如果多样本缓冲区不可用,则输入变化将在像素的中心进行评估/n如果样本编号sample不存在,则用于插值输入变量的位置undefined\n\n"
	},

	"texelFetch 查找单个纹素": {
		"prefix": "texelFetch",
		"body": [
			"texelFetch(${1:sampler}, ${2:P}${3:, ${4:lod/sample/}})$5"
		],
		"description": "gvec4 texelFetch(gsampler1D sampler,int P,int lod);\ngvec4 texelFetch(gsampler2D sampler,ivec2 P,int lod);\ngvec4 texelFetch(gsampler3D sampler,ivec3 P,int lod);\ngvec4 texelFetch(gsampler2DRect sampler,ivec2 P);\ngvec4 texelFetch(gsampler1DArray sampler,ivec2 P,int lod);\ngvec4 texelFetch(gsampler2DArray sampler,ivec3 P,int lod);\ngvec4 texelFetch(gsamplerBuffer sampler,int P);\ngvec4 texelFetch(gsampler2DMS sampler,ivec2 P,sample sample);\ngvec4 texelFetch(gsampler2DMSArray sampler,ivec3 P,sample sample);\n\nsampler:将从中检索纹素的纹理绑定到的采样器\nP:纹理将被采样的纹理坐标\nlod:指定将从中获取纹素的纹理中的细节层次\nsample:对于多重采样获取,指定纹素中的哪个样本将从哪个样本返回\n\n\nTexelFetch从绑定到采样器的纹理中的纹理坐标P中执行单个texel的查找\n数组层在数组形式的P的最后一个组件中指定\nlod指定将从中获取纹素的详细程度\n样本指定从多样本纹理读取时将返回纹素中的哪个样本\n\n"
	},

	"texelFetchOffset 偏移查找单个纹素": {
		"prefix": "texelFetchOffset",
		"body": [
			"texelFetchOffset(${1:sampler}, ${2:P}${3:, ${4:lod}}, ${5:offset})$6"
		],
		"description": "gvec4 texelFetchOffset(gsampler1D sampler,int P,int lod,int offset);\ngvec4 texelFetchOffset(gsampler2D sampler,ivec2 P,int lod,int offset);\ngvec4 texelFetchOffset(gsampler3D sampler,ivec3 P,int lod,int offset);\ngvec4 texelFetchOffset(gsampler2DRect sampler,ivec2 P,int offset);\ngvec4 texelFetchOffset(gsampler1DArray sampler,ivec2 P,int lod,int offset);\ngvec4 texelFetchOffset(gsampler2DArray sampler,ivec3 P,int lod,int offset);\n\nsampler:将从中检索纹素的纹理绑定到的采样器\nP:纹理将被采样的纹理坐标\nlod:指定将从中获取纹素的纹理中的细节层次\noffset:在查找纹素之前应用于P的纹素中的偏移量\n\n\nTexelFetchOffset从绑定到采样器的纹理中的纹理坐标P中执行单个texel的查找,在获取纹素之前,将在offset中指定的偏移量添加到P\noffset必须是一个常量表达式\n数组层在数组形式的P的最后一个组件中指定\nlod指定将从中获取纹素的详细程度\n\n"
	},

	"texture 检索纹素": {
		"prefix": "texture",
		"body": [
			"texture(${1:sampler}, ${2:P}${3:, ${4:[bias]}}${5:, ${6:compare}})$7"
		],
		"description": "gvec4 texture(gsampler1D sampler,float P,[float bias]);\ngvec4 texture(gsampler2D sampler,vec2 P,[float bias]);\ngvec4 texture(gsampler3D sampler,vec3 P,[float bias]);\ngvec4 texture(gsamplerCube sampler,vec3 P,[float bias]);\nfloat texture(sampler1DShadow sampler,vec3 P,[float bias]);\nfloat texture(sampler2DShadow sampler,vec3 P,[float bias]);\nfloat texture(samplerCubeShadow sampler,vec3 P,[float bias]);\ngvec4 texture(gsampler1DArray sampler,vec2 P,[float bias]);\ngvec4 texture(gsampler2DArray sampler,vec3 P,[float bias]);\ngvec4 texture(gsamplerCubeArray sampler,vec4 P,[float bias]);\nfloat texture(sampler1DArrayShadow sampler,vec3 P,[float bias]);\nfloat texture(gsampler2DArrayShadow sampler,vec4 P,[float bias]);\ngvec4 texture(gsampler2DRect sampler,vec2 P);\nfloat texture(sampler2DRectShadow sampler,vec3 P);\nfloat texture(gsamplerCubeArrayShadow sampler,vec4 P,float compare);\n\nsampler:将从中检索纹素的纹理绑定到的采样器\nP:纹理将被采样的纹理坐标\nbias:[可选参数]在详细级别计算期间要应用的偏差\ncompare:从gsamplerCubeArrayShadow采样时将于获取的纹素进行比较的值\n\n\n从纹理中检索纹素"
	},

	"textureGather 收集四个纹素": {
		"prefix": "textureGather",
		"body": [
			"textureGather(${1:sampler}, ${2:P}${3:, ${4:[comp]}}${5:, ${6:refZ}})$7"
		],
		"description": "gvec4 textureGather(gsampler2D sampler,vec2 P,[int comp]);\ngvec4 textureGather(gsampler2DArray sampler,vec3 P,[int comp]);\ngvec4 textureGather(gsamplerCube sampler,vec3 P,[int comp]);\ngvec4 textureGather(gsamplerCubeArray sampler,vec4 P,[int comp]);\ngvec4 textureGather(gsampler2DRect sampler,vec3 P,[int comp]);\nvec4 textureGather(gsampler2DShadow sampler,vec2 P,float refZ);\nvec4 textureGather(gsampler2DArrayShadow sampler,vec3 P,float refZ);\nvec4 textureGather(gsamplerCubeShadow sampler,vec3 P,float refZ);\nvec4 textureGather(gsamplerCubeArrayShadow sampler,vec4 P,float refZ);\nvec4 textureGather(gsampler2DRectShadow sampler,vec3 P,float refZ);\n\nsampler:将从中检索纹素的纹理绑定到的采样器\nP:纹理将被采样的纹理坐标\ncomp:[可选参数]将用于生成结果向量的源纹理的组件\nrefZ:指定阴影形式比较中使用的参考Z值\n\n\ntextureGather返回值如下:\n    vec4(Sample_i0_j1(P, base).comp,\n\tSample_i1_j1(P, base).comp,\n\tSample_i1_j0(P, base).comp,\n\tSample_i0_j0(P, base).comp);\n\n从纹理中收集纹素\n如果指定,comp的值必须为0,1,2,3;分别标识每个纹素的四分量向量查找结果的x,y,z,w分量\n如果未指定comp,则将其视为0,选择每个纹素的x分量生成结果\n\n"
	},

	"textureGatherOffset 偏移收集四个纹素": {
		"prefix": "textureGatherOffset",
		"body": [
			"textureGatherOffset(${1:sampler}, ${2:P}${3:, ${4:refZ}}, ${5:offset}${6:, ${7:[comp]}})$8"
		],
		"description": "gvec4 textureGatherOffset(gsampler2D sampler,vec2 P,ivec2 offset,[int comp]);\ngvec4 textureGatherOffset(gsampler2DArray sampler,vec3 P,ivec2 offset,[int comp]);\ngvec4 textureGatherOffset(gsampler2DRect sampler,vec3 P,ivec2 offset,[int comp]);\nvec4 textureGatherOffset(gsampler2DShadow sampler,vec2 P,float refZ,ivec2 offset);\nvec4 textureGatherOffset(gsampler2DArrayShadow sampler,vec3 P,float refZ,ivec2 offset);\nvec4 textureGatherOffset(gsampler2DRectShadow sampler,vec3 P,float refZ,ivec2 offset);\n\nsampler:将从中检索纹素的纹理绑定到的采样器\nP:纹理将被采样的纹理坐标\ncomp:[可选参数]将用于生成结果向量的源纹理的组件\nrefZ:指定阴影形式比较中使用的参考Z值\noffset:指定从指定纹理坐标P开始的偏移量,纹素将从该坐标处收集\n\n\ntextureGather返回值如下:\n    vec4(Sample_i0_j1(P + offset, base).comp,\n\tSample_i1_j1(P + offset, base).comp,\n\tSample_i1_j0(P + offset, base).comp,\n\tSample_i0_j0(P + offset, base).comp);\n\n\n从带有偏移的纹理中收集四个纹素\n和textureGather相同,但应用了如textureOffset中所述的偏移\n最小偏移值由GL_MIN_PROGRRAM_TEXTURE_GATHER_OFFSET给出\n最大偏移值由GL_MAX_PROGRAM_TEXTURE_GATHER_OFFSET给出\n\n如果指定,comp的值必须为0,1,2,3;分别标识每个纹素的四分量向量查找结果的x,y,z,w分量\n如果未指定comp,则将其视为0,选择每个纹素的x分量生成结果\n\n"
	},

	"textureGatherOffsets 偏移数组收集四个纹素": {
		"prefix": "textureGatherOffsets",
		"body": [
			"textureGatherOffsets(${1:sampler}, ${2:P}${3:, ${4:refZ}}, ${5:offset[4]}${6:, ${7:[comp]}})$8"
		],
		"description": "gvec4 textureGatherOffsets(gsampler2D sampler,vec2 P,ivec2 offset[4],[int comp]);\ngvec4 textureGatherOffsets(gsampler2DArray sampler,vec3 P,ivec2 offset[4],[int comp]);\ngvec4 textureGatherOffsets(gsampler2DRect sampler,vec3 P,ivec2 offset[4],[int comp]);\nvec4 textureGatherOffsets(gsampler2DShadow sampler,vec2 P,float refZ,ivec2 offset[4]);\nvec4 textureGatherOffsets(gsampler2DArrayShadow sampler,vec3 P,float refZ,ivec2 offset[4]);\nvec4 textureGatherOffsets(gsampler2DRectShadow sampler,vec3 P,float refZ,ivec2 offset[4]);\n\nsampler:将从中检索纹素的纹理绑定到的采样器\nP:纹理将被采样的纹理坐标\ncomp:[可选参数]将用于生成结果向量的源纹理的组件\nrefZ:指定阴影形式比较中使用的参考Z值\noffsets:指定从指定纹理坐标P开始的偏移数组,从中收集纹素\n\n\n从具有偏移数组的纹理中收集四个纹素\n与textureGatherOffset的操作相同,只是使用偏移量数组来确定要采样的四个纹素的位置\n四个纹素中的每一个都是通过将offsets中的偏移量作为(u, v)坐标偏移量应用到P,识别四个纹素GL_LINEAR足迹,然后选择该足迹的纹素i0i0来获得的\noffsets中的指定值必须使用常量整数表达式进行设置\n\n"
	},

	"textureGrad 显式梯度纹理查找": {
		"prefix": "textureGrad",
		"body": [
			"textureGrad(${1:sampler}, ${2:P}, ${3:dPdx}, ${4:dPdy})$5"
		],
		"description": "gvec4 textureGrad(gsampler1D sampler,float P,float dPdx,float dPdy);\ngvec4 textureGrad(gsampler2D sampler,vec2 P,vec2 dPdx,vec2 dPdy);\ngvec4 textureGrad(gsampler3D sampler,vec3 P,vec3 dPdx,vec3 dPdy);\ngvec4 textureGrad(gsamplerCube sampler,vec3 P,vec3 dPdx,vec3 dPdy);\ngvec4 textureGrad(gsampler2DRect sampler,vec2 P,vec2 dPdx,vec2 dPdy);\nfloat textureGrad(gsampler2DRectShadow sampler,vec2 P,vec2 dPdx,vec2 dPdy);\nfloat textureGrad(sampler1DShadow sampler,vec3 P,float dPdx,float dPdy);\nfloat textureGrad(sampler2DShadow sampler,vec3 P,vec2 dPdx,vec2 dPdy);\ngvec4 textureGrad(gsampler1DArray sampler,vec2 P,float dPdx,float dPdy);\ngvec4 textureGrad(gsampler2DArray sampler,vec3 P,vec2 dPdx,vec2 dPdy);\nfloat textureGrad(sampler1DArrayShadow sampler,vec3 P,float dPdx,float dPdy);\ngvec4 textureGrad(gsamplerCubeArray sampler,vec4 P,vec3 dPdx,vec3 dPdy);\n\nsampler:将从中检索纹素的纹理绑定到的采样器\nP:纹理将被采样的纹理坐标\ndPdx:P相对于窗口x的偏导数\ndPdy:P相对于窗口y的偏导数\n\n\n使用显式梯度执行纹理查找\ntextureGrad使用dPdx和dPdy中指定的显式纹理坐标梯度在从纹理绑定到采样器的坐标P处执行纹理查找\n对于立方体版本,假定P的偏导数在纹理坐标投影到适当的立方体面上之前使用的坐标系中\n\n"
	},

	"textureGradOffset 显式梯度和偏移进行纹理查找": {
		"prefix": "textureGradOffset",
		"body": [
			"textureGradOffset(${1:sampler}, ${2:P}, ${3:dPdx}, ${4:dPdy}, ${5:offset})$6"
		],
		"description": "gvec4 textureGradOffset(gsampler1D sampler,float P,float dPdx,float dPdy,int offset);\ngvec4 textureGradOffset(gsampler2D sampler,vec2 P,vec2 dPdx,vec2 dPdy,ivec2 offset);\ngvec4 textureGradOffset(gsampler3D sampler,vec3 P,vec3 dPdx,vec3 dPdy,ivec3 offset);\ngvec4 textureGradOffset(gsampler2DRect sampler,vec2 P,vec2 dPdx,vec2 dPdy,ivec2 offset);\nfloat textureGradOffset(gsampler2DRectShadow sampler,vec3 P,vec2 dPdx,vec2 dPdy,ivec2 offset);\nfloat textureGradOffsetsampler1DShadow sampler,vec3 P,float dPdx,float dPdy,int offset);\nfloat textureGradOffset(sampler2DShadow sampler,vec3 P,vec2 dPdx,vec2 dPdy,ivec2 offset);\ngvec4 textureGradOffset(gsampler1DArray sampler,vec2 P,float dPdx,float dPdy,int offset);\ngvec4 textureGradOffset(gsampler2DArray sampler,vec3 P,vec2 dPdx,vec2 dPdy,ivec2 offset);\nfloat textureGradOffset(sampler1DArrayShadow sampler,vec3 P,float dPdx,float dPdy,int offset);\nfloat textureGradOffset(sampler2DArrayShadow sampler,vec3 P,vec2 dPdx,vec2 dPdy,ivec2 offset);\n\nsampler:将从中检索纹素的纹理绑定到的采样器\nP:纹理将被采样的纹理坐标\ndPdx:P相对于窗口x的偏导数\ndPdy:P相对于窗口y的偏导数\noffset:采样前要应用于纹理坐标的偏移量\n\n\n使用显式梯度和偏移执行纹理查找\ntextureGradOffset使用dPdx和dPdy中指定的显式纹理坐标梯度在从纹理绑定到采样器的坐标P处执行纹理查找\noffset中还提供了显式偏移量\ntextureGradOffset使用dPdx和dPdy作为textureGrad;使用offset作为textureOffset\n\n"
	},

	"textureLod 显式细节级别纹理查找": {
		"prefix": "textureLod",
		"body": [
			"textureLod(${1:sampler}, ${2:P}, ${3:lod})$4"
		],
		"description": "gvec4 textureLod(gsampler1D sampler,float P,float lod);\ngvec4 textureLod(gsampler2D sampler,vec2 P,float lod);\ngvec4 textureLod(gsampler3D sampler,vec3 P,float lod);\ngvec4 textureLod(gsamplerCube sampler,vec3 P,float lod);\nfloat textureLod(sampler1DShadow sampler,vec3 P,float lod);\nfloat textureLod(sampler2DShadow sampler,vec4 P,float lod);\ngvec4 textureLod(gsampler1DArray sampler,vec2 P,float lod);\ngvec4 textureLod(gsampler2DArray sampler,vec3 P,float lod);\nfloat textureLod(sampler1DArrayShadow sampler,vec3 P,float lod);\ngvec4 textureLod(gsamplerCubeArray sampler,vec4 P,float lod);\n\nsampler:将从中检索纹素的纹理绑定到的采样器\nP:纹理将被采样的纹理坐标\nlod:指定明确的详细程度\n\n\n执行具有显式细节级别的纹理查找\n\ntextureLod在坐标P从绑定到采样器的纹理执行纹理查找,具有lod中指定的显式细节级别\nlod指定λbase并设置偏导数如下:\nδu/δx=0, δu/δy=0, δv/δx=0\nδv/δy=0, δw/δx=0, δw/δy=0\n\n"
	},

	"textureLodOffset 显式细节级别和偏移进行纹理查找": {
		"prefix": "textureLodOffset",
		"body": [
			"textureLodOffset(${1:sampler}, ${2:P}, ${3:lod}, ${4:offset})$5"
		],
		"description": "gvec4 textureLodOffset(gsampler1D sampler,float P,float lod,int offset);\ngvec4 textureLodOffset(gsampler2D sampler,vec2 P,float lod,ivec2 offset);\ngvec4 textureLodOffset(gsampler3D sampler,vec3 P,float lod,ivec3 offset);\nfloat textureLodOffset(sampler1DShadow sampler,vec3 P,float lod,int offset);\nfloat textureLodOffset(sampler2DShadow sampler,vec4 P,float lod,ivec2 offset);\ngvec4 textureLodOffset(gsampler1DArray sampler,vec2 P,float lod,int offset);\ngvec4 textureLodOffset(gsampler2DArray sampler,vec3 P,float lod,ivec2 offset);\nfloat textureLodOffset(sampler1DArrayShadow sampler,vec3 P,float lod,int offset);\n\nsampler:将从中检索纹素的纹理绑定到的采样器\nP:纹理将被采样的纹理坐标\nlod:指定将从中获取纹素的显式细节级别\noffset:指定在获取纹素之前将应用于P的偏移量\n\n\n使用明确的细节层次和偏移执行纹理查找\n\ntextureLodOffset在坐标P处从绑定到采样器的纹理执行纹理查找,具有在lod中指定的显式细节级别\n行为与textureLod中的相同,只是在采样之前,将偏移量添加到P\n\n"
	},

	"textureOffset 偏移纹理查找": {
		"prefix": "textureOffset",
		"body": [
			"textureOffset(${1:sampler}, ${2:P}, ${3:offset}${4:, ${5:[bias]}})$6"
		],
		"description": "gvec4 textureOffset(gsampler1D sampler,float P,int offset,[float bias]);\ngvec4 textureOffset(gsampler2D sampler,vec2 P,ivec2 offset,[float bias]);\ngvec4 textureOffset(gsampler3D sampler,vec3 P,ivec3 offset,[float bias]);\ngvec4 textureOffset(gsampler2DRect sampler,vec2 P,ivec2 offset);\nfloat textureOffset(sampler2DRectShadow sampler,vec3 P,ivec2 offset);\nfloat textureOffset(sampler1DShadow sampler,vec3 P,int offset,[float bias]);\nfloat textureOffset(sampler2DShadow sampler,vec4 P,ivec2 offset,[float bias]);\ngvec4 textureOffset(gsampler1DArray sampler,vec2 P,int offset,[float bias]);\ngvec4 textureOffset(gsampler2DArray sampler,vec3 P,ivec2 offset,[float bias]);\nfloat textureOffset(sampler1DArrayShadow sampler,vec3 P,int offset);\nfloat textureOffset(sampler2DArrayShadow sampler,vec4 P,vec2 offset);\n\nsampler:将从中检索纹素的纹理绑定到的采样器\nP:纹理将被采样的纹理坐标\noffset:指定在查找纹素之前将应用于P的纹素中的偏移量\n\n\ntextureOffset在从纹理绑定到采样器的坐标P处执行纹理查找,带有一个额外的偏移量,在偏移量中的纹素中指定,在查找每个纹素之前将应用于(u, v, w)纹理坐标\n偏移量必须是常量表达式,支持有限范围的偏移值\n最小和最大偏移值取决于实现:\n· 查询GL_MIN_PROGRAM_TEXEL_OFFSET确定最小值\n· 查询GL_MAX_PROGRAM_TEXEL_OFFSET确定最大值\n\n注意:\n   offset不适用于纹理数组的层坐标\n   立方体贴图不支持偏移\n\n"
	},

	"textureProj 投影纹理查找": {
		"prefix": "textureProj",
		"body": [
			"textureProj(${1:sampler}, ${2:P}${3:, ${4:[bias]}})$5"
		],
		"description": "gvec4 textureProj(gsampler1D sampler,vec2 P,[float bias]);\ngvec4 textureProj(gsampler1D sampler,vec4 P,[float bias]);\ngvec4 textureProj(gsampler2D sampler,vec3 P,[float bias]);\ngvec4 textureProj(gsampler2D sampler,vec4 P,[float bias]);\ngvec4 textureProj(gsampler3D sampler,vec4 P,[float bias]);\nfloat textureProj(sampler1DShadow sampler,vec4 P,[float bias]);\nfloat textureProj(sampler2DShadow sampler,vec4 P,[float bias]);\ngvec4 textureProj(gsampler2DRect sampler,vec3 P);\ngvec4 textureProj(gsampler2DRect sampler,vec4 P);\nfloat textureProj(gsampler2DRectShadow sampler,vec4 P);\n\nsampler:将从中检索纹素的纹理绑定到的采样器\nP:纹理将被采样的纹理坐标\nbias:[可选参数]指定在详细级别计算期间要应用的偏差\n\n\n使用投影执行纹理查找\n\n从P消耗的纹理坐标(不包括P的最后一个分量)除以P的最后一个分量\n得到的P在阴影形式中的3rd分量用作Dref\n计算完这些值后,纹理查找将像在textrue中一样进行\n\n"
	},

	"textureProjGrad 投影和显式梯度纹理查找": {
		"prefix": "textureProjGrad",
		"body": [
			"textureProjGrad(${1:sampler}, ${2:P}, ${3:dPdx}, ${4:dPdy})$5"
		],
		"description": "gvec4 textureProjGrad(gsampler1D sampler,vec2 P,float pDx,float pDy);\ngvec4 textureProjGrad(gsampler1D sampler,vec4 P,float pDx,float pDy);\ngvec4 textureProjGrad(gsampler2D sampler,vec3 P,vec2 pDx,vec2 pDy);\ngvec4 textureProjGrad(gsampler2D sampler,vec4 P,vec2 pDx,vec2 pDy);\ngvec4 textureProjGrad(gsampler3D sampler,vec4 P,vec3 pDx,vec3 pDy);\nfloat textureProjGrad(sampler1DShadow sampler,vec4 P,float pDx,float pDy);\nfloat textureProjGrad(sampler2DShadow sampler,vec4 P,vec2 pDx,vec2 pDy);\ngvec4 textureProjGrad(gsampler2DRect sampler,vec3 P,vec2 pDx,vec2 pDy);\ngvec4 textureProjGrad(gsampler2DRect sampler,vec4 P,vec2 pDx,vec2 pDy);\nfloat textureProjGrad(gsampler2DRectShadow sampler,vec4 P,vec2 pDx,vec2 pDy);\n\nsampler:将从中检索纹素的纹理绑定到的采样器\nP:纹理将被采样的纹理坐标\ndPdx:指定P相对于窗口x的偏导数\ndPdy:指定P相对于窗口y的偏导数\n\n\n使用投影和显式梯度执行纹理查找\n\n从P消耗的纹理坐标(不包括P的最后一个分量)除以P的最后一个分量\n得到的P在阴影形式中的3rd分量用作Dref\n计算完这些值后,纹理查找将像在textrueGrad中一样进行,将dPdx和dPdy作为梯度传递\n\n"
	},

	"textureProjGradOffset 投影、显式梯度和偏移纹理查找": {
		"prefix": "textureProjGradOffset",
		"body": [
			"textureProjGradOffset(${1:sampler}, ${2:P}, ${3:dPdx}, ${4:dPdy}, ${5:offset})%6"
		],
		"description": "gvec4 textureProjGradOffset(gsampler1D sampler,vec2 P,float dPdx,float dPdy,int offset);\ngvec4 textureProjGradOffset(gsampler1D sampler,vec4 P,float dPdx,float dPdy,int offset);\ngvec4 textureProjGradOffset(gsampler2D sampler,vec3 P,vec2 dPdx,vec2 dPdy,ivec2 offset);\ngvec4 textureProjGradOffset(gsampler2D sampler,vec4 P,vec2 dPdx,vec2 dPdy,ivec2 offset);\ngvec4 textureProjGradOffset(gsampler3D sampler,vec4 P,vec3 dPdx,vec3 dPdy,ivec3 offset);\nfloat textureProjGradOffset(sampler1DShadow sampler,vec4 P,float dPdx,float dPdy,int offset);\nfloat textureProjGradOffset(sampler2DShadow sampler,vec4 P,vec2 dPdx,vec2 dPdy,ivec2 offset);\ngvec4 textureProjGradOffset(gsampler2DRect sampler,vec3 P,vec2 dPdx,vec2 dPdy,ivec2 offset);\ngvec4 textureProjGradOffset(gsampler2DRect sampler,vec4 P,vec2 dPdx,vec2 dPdy,ivec2 offset);\nfloat textureProjGradOffset(gsampler2DRectShadow sampler,vec4 P,vec2 dPdx,vec2 dPdy,ivec2 offset);\n\nsampler:将从中检索纹素的纹理绑定到的采样器\nP:纹理将被采样的纹理坐标\ndPdx:指定P相对于窗口x的偏导数\ndPdy:指定P相对于窗口y的偏导数,offset:指定偏移量,以纹素为单位,纹理将相对于P的投影进行采样\n\n\n使用投影、显式梯度和偏移执行纹理查找\n\n从P消耗的纹理坐标(不包括P的最后一个分量)除以P的最后一个分量\n得到的P在阴影形式中的3rd分量用作Dref\n计算完这些值后,纹理查找将像在textureGradOffset中一样进行,将dPdx和dPdy作为梯度传递,将offset作为偏移量传递\n\n"
	},

	"textureProjLod 投影和显式细节级别纹理查找": {
		"prefix": "textureProjLod",
		"body": [
			"textureProjLod(${1:sampler}, ${2:P}, ${3:lod})$4"
		],
		"description": "gvec4 textureProjLod(gsampler1D sampler,vec2 P,float lod);\ngvec4 textureProjLod(gsampler1D sampler,vec4 P,float lod);\ngvec4 textureProjLod(gsampler2D sampler,vec3 P,float lod);\ngvec4 textureProjLod(gsampler2D sampler,vec4 P,float lod);\ngvec4 textureProjLod(gsampler3D sampler,vec4 P,float lod);\nfloat textureProjLod(sampler1DShadow sampler,vec4 P,float lod);\nfloat textureProjLod(sampler2DShadow sampler,vec4 P,float lod);\n\nsampler:将从中检索纹素的纹理绑定到的采样器\nP:纹理将被采样的纹理坐标\nlod:指定要从中获取纹素的显式细节级别\n\n\ntextureProjLod使用来自明确指定的细节层次的投影执行纹理查找\n从P消耗的纹理坐标(不包括P的最后一个分量)除以P的最后一个分量\n得到的P在阴影形式中的3rd分量用作Dref\n计算完这些值后,纹理查找将像在textureLod中一样进行\nlod用于指定将从中对纹理进行采样的细节级别\n\n"
	},

	"textureProjLodOffset 投影、显式细节级别和偏移纹理查找": {
		"prefix": "textureProjLodOffset",
		"body": [
			"textureProjLodOffset(${1:sampler}, ${2:P}, ${3:lod}, ${4:offset})$5"
		],
		"description": "gvec4 textureProjLodOffset(gsampler1D sampler,vec2 P,float lod,int offset);\ngvec4 textureProjLodOffset(gsampler1D sampler,vec4 P,float lod,int offset);\ngvec4 textureProjLodOffset(gsampler2D sampler,vec3 P,float lod,ivec2 offset);\ngvec4 textureProjLodOffset(gsampler2D sampler,vec4 P,float lod,ivec2 offset);\ngvec4 textureProjLodOffset(gsampler3D sampler,vec4 P,float lod,ivec3 offset);\nfloat textureProjLodOffset(sampler1DShadow sampler,vec4 P,float lod,int offset);\nfloat textureProjLodOffset(sampler2DShadow sampler,vec4 P,float lod,ivec2 offset);\n\nsampler:将从中检索纹素的纹理绑定到的采样器\nP:纹理将被采样的纹理坐标\nlod:指定要从中获取纹素的显式细节级别\noffset:指定在获取纹素之前要应用于P中的偏移量(以纹素为单位)\n\n\ntextureProjLodOffset使用从显式指定的细节层次的投影执行纹理查找,并在采样前将偏移应用于纹理坐标\n\n从P消耗的纹理坐标(不包括P的最后一个分量)除以P的最后一个分量\n得到的P在阴影形式中的3rd分量用作Dref\n计算完这些值后,纹理查找将像在textureLodOffset中一样进行\nlod用于指定纹理将从其采样的细节级别\noffset用于指定采样前要应用于纹理坐标的偏移量(以纹素为单位)\n\n"
	},

	"textureProjOffset 投影和偏移纹理查找": {
		"prefix": "textureProjOffset",
		"body": [
			"textureProjOffset(${1:sampler}, ${2:P}, ${3:offset}${4:, ${5:[bias]}})$6"
		],
		"description": "gvec4 textureProjOffset(gsampler1D sampler,vec2 P,int offset,[float bias]);\ngvec4 textureProjOffset(gsampler1D sampler,vec4 P,int offset,[float bias]);\ngvec4 textureProjOffset(gsampler2D sampler,vec3 P,ivec2 offset,[float bias]);\ngvec4 textureProjOffset(gsampler2D sampler,vec4 P,ivec2 offset,[float bias]);\ngvec4 textureProjOffset(gsampler3D sampler,vec4 P,ivec3 offset,[float bias]);\nfloat textureProjOffset(sampler1DShadow sampler,vec4 P,int offset,[float bias]);\nfloat textureProjOffset(sampler2DShadow sampler,vec4 P,ivec2 offset,[float bias]);\ngvec4 textureProjOffset(gsampler2DRect sampler,vec3 P,ivec2 offset);\ngvec4 textureProjOffset(gsampler2DRect sampler,vec4 P,ivec2 offset);\nfloat textureProjOffset(gsampler2DRectShadow sampler,vec4 P,ivec2 offset);\n\nsampler:将从中检索纹素的纹理绑定到的采样器\nP:纹理将被采样的纹理坐标\noffset:指定在采样发生前应用于P的偏移量\nbias:[可选参数]指定在详细级别计算期间要应用的偏差\n\n\ntextureProjOffset使用投影执行纹理查找\n从P消耗的纹理坐标(不包括P的最后一个分量)除以P的最后一个分量\n得到的P在阴影形式中的3rd分量用作Dref\n计算完这些值后,纹理查找将像在textureOffset中一样进行\noffset用于偏移计算的纹理坐标\n\n"
	},

	"textureQueryLevels 计算mipmap级别": {
		"prefix": "textureQueryLevels",
		"body": [
			"textureQueryLevels(${1:sampler})$2"
		],
		"description": "int textureQueryLevels(gsampler1D sampler);\nint textureQueryLevels(gsampler2D sampler);\nint textureQueryLevels(gsampler3D sampler);\nint textureQueryLevels(gsamplerCube sampler);\nint textureQueryLevels(gsampler1DArray sampler);\nint textureQueryLevels(gsampler2DDArray sampler);\nint textureQueryLevels(gsamplerCubeArray sampler);\nint textureQueryLevels(gsampler1DShadow sampler);\nint textureQueryLevels(gsampler2DShadow sampler);\nint textureQueryLevels(gsamplerCubeShadow sampler);\nint textureQueryLevels(gsampler1DArrayShadow sampler);\nint textureQueryLevels(gsampler2DArrayShadow sampler);\nint textureQueryLevels(gsamplerCubeArrayShadow sampler);\n\nsampler:指定将查询mipmap级别计数的纹理绑定到的采样器\n\n\n返回与采样器关联的纹理中可访问的mipmap级别数\n如果在不完整的纹理上调用,或者没有纹理与采样器关联,则返回0\n\n"
	},

	"textureQueryLod 计算细节级别": {
		"prefix": "textureQueryLod",
		"body": [
			"textureQueryLod(${1:sampler}, ${2:P})$3"
		],
		"description": "vec2 textureQueryLod(gsampler1D sampler,float P);\nvec2 textureQueryLod(gsampler2D sampler,vec2 P);\nvec2 textureQueryLod(gsampler3D sampler,vec3 P);\nvec2 textureQueryLod(gsamplerCube sampler,vec3 P);\nvec2 textureQueryLod(gsampler1DArray sampler,float P);\nvec2 textureQueryLod(gsampler2DDArray sampler,vec2 P);\nvec2 textureQueryLod(gsamplerCubeArray sampler,vec3 P);\nvec2 textureQueryLod(sampler1DShadow sampler,float P);\nvec2 textureQueryLod(sampler2DShadow sampler,vec2 P);\nvec2 textureQueryLod(samplerCubeShadow sampler,vec3 P);\nvec2 textureQueryLod(sampler1DArrayShadow sampler,float P);\nvec2 textureQueryLod(sampler2DArrayShadow sampler,vec2 P);\nvec2 textureQueryLod(samplerCubeArrayShadow sampler,vec3 P);\n\nsampler:指定将查询其细节级别的纹理绑定到的采样器\nP:指定将查询细节级别的纹理坐标\n\n\n仅在片段着色器中可用\ntextureQueryLod计算将用于从纹理中采样的细节级别\n将被访问的mipmap数组在返回值的x分量中返回\n在返回值的y分两种返回计算的相对于基本级别的详细级别\n如果在不完整的纹理上调用,则操作的结果是undefined\n\n"
	},

	"textureSamples 纹理样本数": {
		"prefix": "textureSamples",
		"body": [
			"textureSamples(${1:sampler})$2"
		],
		"description": "int textureSamples(gsampler2DMS sampler);\nint textureSamples(gsampler2DMSArray sampler);\n\nsampler:指定纹理绑定到的采样器\n\n\n返回绑定到采样器的纹理的每个纹素的样本数\n\n"
	},

	"textureSize 纹理级别尺寸": {
		"prefix": "textureSize",
		"body": [
			"textureSize(${1:sampler}${2:, ${3:lod}})$4"
		],
		"description": "int textureSize(gsampler1D sampler,int lod);\nivec2 textureSize(gsampler2D sampler,int lod);\nivec3 textureSize(gsampler3D sampler,int lod);\nivec2 textureSize(gsamplerCube sampler,int lod);\nint textureSize(sampler1DShadow sampler,int lod);\nivec2 textureSize(sampler2DShadow sampler,int lod);\nivec2 textureSize(samplerCubeShadow sampler,int lod);\nivec3 textureSize(samplerCubeArray sampler,int lod);\nivec3 textureSize(samplerCubeArrayShadow sampler,int lod);\nivec2 textureSize(gsamplerRect sampler);\nivec2 textureSize(gsamplerRectShadow sampler);\nivec2 textureSize(gsampler1DArray sampler,int lod);\nivec3 textureSize(gsampler2DArray sampler,int lod);\nivec2 textureSize(sampler1DArrayShadow sampler,int lod);\nivec3 textureSize(sampler2DArrayShadow sampler,int lod);\nint textureSize(gsamplerBuffer sampler);\nivec2 textureSize(gsampler2DMS sampler);\nivec3 textureSize(gsampler2DMSArray sampler);\n\nsampler:指定要检索其尺寸的纹理绑定到的采样器\nlod:指定要为其检索尺寸的纹理级别\n\n\n返回绑定到采样器的纹理的级别lod(如果存在)的尺寸\n返回值中的组件一次填充纹理的宽度、高度和深度\n对于数组形式,返回值的最后一个组成部分是纹理数组中的层数\n\n"
	},

	//Matrix 矩阵

	"determinant 计算行列式": {
		"prefix": "determinant",
		"body": [
			"determinant(${1:m})$2"
		],
		"description": "float determinant(mat2 m);\nfloat determinant(mat3 m);\nfloat determinant(mat4 m);\ndouble determinant(dmat2 m);\ndouble determinant(dmat3 m);\ndouble determinant(dmat4 m);\n\n返回矩阵m的行列式\n\n"
	},

	"inverse 计算逆矩阵": {
		"prefix": "inverse",
		"body": [
			"inverse(${1:m})$2"
		],
		"description": "mat2 inverse(mat2 m);\nmat3 inverse(mat3 m);\nmat4 inverse(mat4 m);\ndmat2 inverse(dmat2 m);\ndmat3 inverse(dmat3 m);\ndmat4 inverse(dmat4 m);\n\n返回矩阵m的逆矩阵\n\n"
	},

	"matrixCompMult 矩阵乘": {
		"prefix": "matrixCompMult",
		"body": [
			"matrixCompMult(${1:m1}, ${2:m2})$3"
		],
		"description": "mat matrixCompMult(mat x,mat y);\ndmat matrixCompMult(dmat x,dmat y);\n\n执行两个矩阵的按分量相乘,产生一个结果矩阵\n其中每个分量result[i][j]计算为x[i][j]和y[i][j]的标量积\n\n"
	},

	"outerProduct 计算外积": {
		"prefix": "outerProduct",
		"body": [
			"outerProduct(${1:column}, ${2:row})$3"
		],
		"description": "mat2 outerProduct(vec2 c,vec2 r);\nmat3 outerProduct(vec3 c,vec3 r);\nmat4 outerProduct(vec4 c,vec4 r);\nmat2x3 outerProduct(vec3 c,vec2 r);\nmat3x2 outerProduct(vec2 c,vec3 r);\nmat2x4 outerProduct(vec4 c,vec2 r);\nmat4x2 outerProduct(vec2 c,vec4 r);\nmat3x4 outerProduct(vec4 c,vec3 r);\nmat4x3 outerProduct(vec3 c,vec4 r);\ndmat2 outerProduct(dvec2 c,dvec2 r);\ndmat3 outerProduct(dvec3 c,dvec3 r);\ndmat4 outerProduct(dvec4 c,dvec4 r);\ndmat2x3 outerProduct(dvec3 c,dvec2 r);\ndmat3x2 outerProduct(dvec2 c,dvec3 r);\ndmat2x4 outerProduct(dvec4 c,dvec2 r);\ndmat4x2 outerProduct(dvec2 c,dvec4 r);\ndmat3x4 outerProduct(dvec4 c,dvec3 r);\ndmat4x3 outerProduct(dvec3 c,dvec4 r);\n\n将第一个参数c视为列向量,将第二个参数r视为行向量\n以线性代数矩阵相乘计算c*r,得到一个矩阵\n其行数为c中组件数,列数是r中组件数\n\n"
	},

	"transpose 矩阵转置": {
		"prefix": "transpose",
		"body": [
			"transpose(${1:m})$2"
		],
		"description": "mat2 transpose(mat2 m);\nmat3 transpose(mat3 m);\nmat4 transpose(mat4 m);\nmat2x3 transpose(mat3x2 m);\nmat2x4 transpose(mat4x2 m);\nmat3x2 transpose(mat2x3 m);\nmat3x4 transpose(mat4x3 m);\nmat4x2 transpose(mat2x4 m);\nmat4x3 transpose(mat3x4 m);\ndmat2 transpose(dmat2 m);\ndmat3 transpose(dmat3 m);\ndmat4 transpose(dmat4 m);\ndmat2x3 transpose(dmat3x2 m);\ndmat2x4 transpose(dmat4x2 m);\ndmat3x2 transpose(dmat2x3 m);\ndmat3x4 transpose(dmat4x3 m);\ndmat4x2 transpose(dmat2x4 m);\ndmat4x3 transpose(dmat3x4 m);\n\n返回矩阵m的转置\n\n"
	},

	//Integer 整数

	"bitCount": {
		"prefix": "bitCount",
		"body": [
			"bitCount(${1:value})$2"
		],
		"description": "genIType bitCount(genIType value);\ngenIType bitCount(genUType value);\n\n返回value的二进制表示中1的个数\n\n"
	},

	"bitfieldExtract": {
		"prefix": "bitfieldExtract",
		"body": [
			"bitfieldExtract(${1:value}, ${2:offset}, ${3:bits})$4"
		],
		"description": "genIType bitfieldExtract(genIType value,int offset,int bits);\ngenUType bitfieldExtract(genUType value,int offset,int bits);\n\nvalue:指定从中提取位的整数\noffset:指定要提取的第一位的索引\nbits:指定要提取的位数\n\n\nbitfieldExtract提取value位的子集并在结果的最低有效位中返回它\n提取的位范围为[offset, offset + bits + 1]\n对于无符号数据类型,结果的最高有效位将设置为0\n对于有符号数据类型,最高有效位将设置为offset + bits - 1(符号扩展到返回类型的宽度)\n如果位为0,则结果为0\n如果offset或bits为负,或者offset和bits的总和大于用于存储操作数的位数,则结果将undefined\n\n"
	},

	"bitfieldInsert": {
		"prefix": "bitfieldInsert",
		"body": [
			"bitfieldInsert(${1:base}, ${2:insert}, ${3:offset}, ${4:bits})$5"
		],
		"description": "genIType bitfieldInsert(genIType base,genIType insert,int offset,int bits);\ngenUType bitfieldInsert(genUType base,genUType insert,int offset,int bits);\n\nbase:指定要被插入insert的整数\ninsert:指定要插入的位的值\noffset:指定要插入的第一位的索引\nbits:指定要插入的位数\n\n\n在base的偏移offset处将insert的最低有效位插入bits个\n返回值的位[offset, offset + bits + 1]取自insert的[0, bits - 1],所有其他位置直接取自对应的base位\n如果bits为0,则结果将只是base的原始值\n如果offset或bits为0,或者offset和bits的总和大于用于存储操作数的位数,则结果undefined\n\n"
	},

	"bitfieldReverse": {
		"prefix": "bitfieldReverse",
		"body": [
			"bitfieldReverse(${1:value})$2"
		],
		"description": "genIType bitfieldReverse(genIType value);\ngenUType bitfieldReverse(genUType value);\n\n反转value的位顺序\n编号位n的位将取自value的(bits - 1) - n\n   bits表示value的总位数\n\n"
	},

	"findLSB": {
		"prefix": "findLSB",
		"body": [
			"findLSB(${1:value})$2"
		],
		"description": "genIType findLSB(genIType value);\ngenIType findLSB(genUType value);\n\n返回value的二进制表示中设置为1的最低有效位的位数\n如果value为0,则返回-1\n\n"
	},

	"findMSB": {
		"prefix": "findMSB",
		"body": [
			"findMSB(${1:value})$2"
		],
		"description": "genIType findMSB(genIType value);\ngenIType findMSB(genUType value);\n\n返回value的二进制表示中设置为1的最高有效位的位数\n   对于正整数,结果僵尸设置为1的最高有效位的位数\n   对于负整数,结果将是设置为0的最高有效位的位数\n   对于0或-1,返回-1\n\n"
	},

	"uaddCarry": {
		"prefix": "uaddCarry",
		"body": [
			"uaddCarry(${1:x}, ${2:y}, ${3:carry})$4"
		],
		"description": "genUType uaddCarry(genUType x,genUType y,out genUType carry);\n\nx:指定要在求和运算中使用的第一个向量\ny:指定要在求和运算中使用的第二个向量\ncarry:和的进位输出\n\n\n将两个32位无符号整型变量(标量或向量)相加并生成一个32位无符号整数结果以及一个进位输出\n结果是x和y模2^32的总和\n如果总和小于2^32,则carry设置为0,否则设置为1\n\n"
	},

	"umulExtended": {
		"prefix": "umulExtended",
		"body": [
			"${1|u,i|}mulExtended(${2:x}, ${3:y}, ${4:msb}, ${5:lsb})$6"
		],
		"description": "void umulExtended(genUType x,genUType y,out genUType msb,out genUType lsb);\nvoid imulExtended(genIType x,genIType y,out genIType msb,out genIType lsb);\n\nx:第一个被乘数\ny:第二个被乘数\nmsb:结果的32个最高有效位\nlsb:结果的32个最低有效位\n\n\n执行两个32位整数x和y的乘法,产生64位整数结果\n乘积的32个最低有效位返回至lsb\n乘积的32个最高有效位返回至msb\n\numulExtended 和 imulExtended分别执行无符号和有符号乘法\n\n"
	},

	"usubBorrow": {
		"prefix": "usubBorrow",
		"body": [
			"usubBorrow(${1:x}, ${2:y}, ${3:borrow})$4"
		],
		"description": "genUType usubBorrow(genUType x,genUType y,out genUType borrow);\n\nx:指定要在减法运算中使用的第一个向量\ny:指定要在减法运算中使用的第二个向量\nborrow:差的借位输出\n\n\n减去两个32位无符号整型变量(标量或向量)并生成一个32位无符号整数结果以及借位输出\n结果是x和y的差(如果非负),否则为2^32加上该差\n如果x>=y,则borrow设置为0,否则设置为1\n\n"
	},

	//Image 图片

	"imageAtomicAdd": {
		"prefix": "imageAtomicAdd",
		"body": [
			"imageAtomicAdd(${1:image}, ${2:P}${3:, ${4:sample}}, ${5:data})$6"
		],
		"description": "uint imageAtomicAdd(gimage1D image,int P,uint data);\nuint imageAtomicAdd(gimage2D image,ivec2 P,uint data);\nuint imageAtomicAdd(gimage3D image,ivec3 P,uint data);\nuint imageAtomicAdd(gimage2DRect image,ivec2 P,uint data);\nuint imageAtomicAdd(gimageCube image,ivec3 P,uint data);\nuint imageAtomicAdd(gbufferImage image,int P,uint data);\nuint imageAtomicAdd(gimage1DArray image,ivec2 P,uint data);\nuint imageAtomicAdd(gimage2DArray image,ivec3 P,uint data);\nuint imageAtomicAdd(gimageCubeArray image,ivec3 P,uint data);\nuint imageAtomicAdd(gimage2DMS image,ivec2 P,int sample,uint data);\nuint imageAtomicAdd(gimage2DMSArray image,ivec3 P,int sample,uint data);\nint imageAtomicAdd(gimage1D image,int P,int data);\nint imageAtomicAdd(gimage2D image,ivec2 P,int data);\nint imageAtomicAdd(gimage3D image,ivec3 P,int data);\nint imageAtomicAdd(gimage2DRect image,ivec2 P,int data);\nint imageAtomicAdd(gimageCube image,ivec3 P,int data);\nint imageAtomicAdd(gbufferImage image,int P,int data);\nint imageAtomicAdd(gimage1DArray image,ivec2 P,int data);\nint imageAtomicAdd(gimage2DArray image,ivec3 P,int data);\nint imageAtomicAdd(gimageCubeArray image,ivec3 P,int data);\nint imageAtomicAdd(gimage2DMS image,ivec2 P,int sample,int data);\nint imageAtomicAdd(gimage2DMSArray image,ivec3 P,int sample,int data);\n\n"
	},

	"imageAtomicAnd": {
		"prefix": "imageAtomicAnd",
		"body": [
			"imageAtomicAnd(${1:image}, ${2:P}${3:, ${4:sample}}, ${5:data})$6"
		],
		"description": "uint imageAtomicAnd(gimage1D image,int P,uint data);\nuint imageAtomicAnd(gimage2D image,ivec2 P,uint data);\nuint imageAtomicAnd(gimage3D image,ivec3 P,uint data);\nuint imageAtomicAnd(gimage2DRect image,ivec2 P,uint data);\nuint imageAtomicAnd(gimageCube image,ivec3 P,uint data);\nuint imageAtomicAnd(gbufferImage image,int P,uint data);\nuint imageAtomicAnd(gimage1DArray image,ivec2 P,uint data);\nuint imageAtomicAnd(gimage2DArray image,ivec3 P,uint data);\nuint imageAtomicAnd(gimageCubeArray image,ivec3 P,uint data);\nuint imageAtomicAnd(gimage2DMS image,ivec2 P,int sample,uint data);\nuint imageAtomicAnd(gimage2DMSArray image,ivec3 P,int sample,uint data);\nint imageAtomicAnd(gimage1D image,int P,int data);\nint imageAtomicAnd(gimage2D image,ivec2 P,int data);\nint imageAtomicAnd(gimage3D image,ivec3 P,int data);\nint imageAtomicAnd(gimage2DRect image,ivec2 P,int data);\nint imageAtomicAnd(gimageCube image,ivec3 P,int data);\nint imageAtomicAnd(gbufferImage image,int P,int data);\nint imageAtomicAnd(gimage1DArray image,ivec2 P,int data);\nint imageAtomicAnd(gimage2DArray image,ivec3 P,int data);\nint imageAtomicAnd(gimageCubeArray image,ivec3 P,int data);\nint imageAtomicAnd(gimage2DMS image,ivec2 P,int sample,int data);\nint imageAtomicAnd(gimage2DMSArray image,ivec3 P,int sample,int data);\n\n"
	},

	"imageAtomicCompSwap": {
		"prefix": "imageAtomicCompSwap",
		"body": [
			"imageAtomicCompSwap(${1:image}, ${2:P}${3:, ${4:sample}}, ${5:compare}, ${6:data})$7"
		],
		"description": "uint imageAtomicCompSwap(gimage1D image,int P,uint compare,uint data);\nuint imageAtomicCompSwap(gimage2D image,ivec2 P,uint compare,uint data);\nuint imageAtomicCompSwap(gimage3D image,ivec3 P,uint compare,uint data);\nuint imageAtomicCompSwap(gimage2DRect image,ivec2 P,uint compare,uint data);\nuint imageAtomicCompSwap(gimageCube image,ivec3 P,uint compare,uint data);\nuint imageAtomicCompSwap(gbufferImage image,int P,uint compare,uint data);\nuint imageAtomicCompSwap(gimage1DArray image,ivec2 P,uint compare,uint data);\nuint imageAtomicCompSwap(gimage2DArray image,ivec3 P,uint compare,uint data);\nuint imageAtomicCompSwap(gimageCubeArray image,ivec3 P,uint compare,uint data);\nuint imageAtomicCompSwap(gimage2DMS image,ivec2 P,int sample,uint compare,uint data);\nuint imageAtomicCompSwap(gimage2DMSArray image,ivec3 P,int sample,uint compare,uint data);\nint imageAtomicCompSwap(gimage1D image,int P,int compare,int data);\nint imageAtomicCompSwap(gimage2D image,ivec2 P,int compare,int data);\nint imageAtomicCompSwap(gimage3D image,ivec3 P,int compare,int data);\nint imageAtomicCompSwap(gimage2DRect image,ivec2 P,int compare,int data);\nint imageAtomicCompSwap(gimageCube image,ivec3 P,int compare,int data);\nint imageAtomicCompSwap(gbufferImage image,int P,int compare,int data);\nint imageAtomicCompSwap(gimage1DArray image,ivec2 P,int compare,int data);\nint imageAtomicCompSwap(gimage2DArray image,ivec3 P,int compare,int data);\nint imageAtomicCompSwap(gimageCubeArray image,ivec3 P,int compare,int data);\nint imageAtomicCompSwap(gimage2DMS image,ivec2 P,int sample,int compare,int data);\nint imageAtomicCompSwap(gimage2DMSArray image,ivec3 P,int sample,int compare,int data);\n\n"
	},

	"imageAtomicExchange": {
		"prefix": "imageAtomicExchange",
		"body": [
			"imageAtomicExchange(${1:image}, ${2:P}${3:, ${4:sample}}, ${5:data})$6"
		],
		"description": "uint imageAtomicExchange(gimage1D image,int P,uint data);\nuint imageAtomicExchange(gimage2D image,ivec2 P,uint data);\nuint imageAtomicExchange(gimage3D image,ivec3 P,uint data);\nuint imageAtomicExchange(gimage2DRect image,ivec2 P,uint data);\nuint imageAtomicExchange(gimageCube image,ivec3 P,uint data);\nuint imageAtomicExchange(gbufferImage image,int P,uint data);\nuint imageAtomicExchange(gimage1DArray image,ivec2 P,uint data);\nuint imageAtomicExchange(gimage2DArray image,ivec3 P,uint data);\nuint imageAtomicExchange(gimageCubeArray image,ivec3 P,uint data);\nuint imageAtomicExchange(gimage2DMS image,ivec2 P,int sample,uint data);\nuint imageAtomicExchange(gimage2DMSArray image,ivec3 P,int sample,uint data);\nint imageAtomicExchange(gimage1D image,int P,int data);\nint imageAtomicExchange(gimage2D image,ivec2 P,int data);\nint imageAtomicExchange(gimage3D image,ivec3 P,int data);\nint imageAtomicExchange(gimage2DRect image,ivec2 P,int data);\nint imageAtomicExchange(gimageCube image,ivec3 P,int data);\nint imageAtomicExchange(gbufferImage image,int P,int data);\nint imageAtomicExchange(gimage1DArray image,ivec2 P,int data);\nint imageAtomicExchange(gimage2DArray image,ivec3 P,int data);\nint imageAtomicExchange(gimageCubeArray image,ivec3 P,int data);\nint imageAtomicExchange(gimage2DMS image,ivec2 P,int sample,int data);\nint imageAtomicExchange(gimage2DMSArray image,ivec3 P,int sample,int data);\nint imageAtomicExchange(gimage1D image,int P,float data);\nint imageAtomicExchange(gimage2D image,ivec2 P,float data);\nint imageAtomicExchange(gimage3D image,ivec3 P,float data);\nint imageAtomicExchange(gimage2DRect image,ivec2 P,float data);\nint imageAtomicExchange(gimageCube image,ivec3 P,float data);\nint imageAtomicExchange(gbufferImage image,int P,float data);\nint imageAtomicExchange(gimage1DArray image,ivec2 P,float data);\nint imageAtomicExchange(gimage2DArray image,ivec3 P,float data);\nint imageAtomicExchange(gimageCubeArray image,ivec3 P,float data);\nint imageAtomicExchange(gimage2DMS image,ivec2 P,int sample,float data);\nint imageAtomicExchange(gimage2DMSArray image,ivec3 P,int sample,float data);\n\n"
	},

	"imageAtomicMax": {
		"prefix": "imageAtomicMax",
		"body": [
			"imageAtomicMax(${1:image}, ${2:P}${3:, ${4:sample}}, ${5:data})$6"
		],
		"description": "uint imageAtomicMax(gimage1D image,int P,uint data);\nuint imageAtomicMax(gimage2D image,ivec2 P,uint data);\nuint imageAtomicMax(gimage3D image,ivec3 P,uint data);\nuint imageAtomicMax(gimage2DRect image,ivec2 P,uint data);\nuint imageAtomicMax(gimageCube image,ivec3 P,uint data);\nuint imageAtomicMax(gbufferImage image,int P,uint data);\nuint imageAtomicMax(gimage1DArray image,ivec2 P,uint data);\nuint imageAtomicMax(gimage2DArray image,ivec3 P,uint data);\nuint imageAtomicMax(gimageCubeArray image,ivec3 P,uint data);\nuint imageAtomicMax(gimage2DMS image,ivec2 P,int sample,uint data);\nuint imageAtomicMax(gimage2DMSArray image,ivec3 P,int sample,uint data);\nint imageAtomicMax(gimage1D image,int P,int data);\nint imageAtomicMax(gimage2D image,ivec2 P,int data);\nint imageAtomicMax(gimage3D image,ivec3 P,int data);\nint imageAtomicMax(gimage2DRect image,ivec2 P,int data);\nint imageAtomicMax(gimageCube image,ivec3 P,int data);\nint imageAtomicMax(gbufferImage image,int P,int data);\nint imageAtomicMax(gimage1DArray image,ivec2 P,int data);\nint imageAtomicMax(gimage2DArray image,ivec3 P,int data);\nint imageAtomicMax(gimageCubeArray image,ivec3 P,int data);\nint imageAtomicMax(gimage2DMS image,ivec2 P,int sample,int data);\nint imageAtomicMax(gimage2DMSArray image,ivec3 P,int sample,int data);\n\n"
	},

	"imageAtomicMin": {
		"prefix": "imageAtomicMin",
		"body": [
			"imageAtomicMin(${1:image}, ${2:P}${3:, ${4:sample}}, ${5:data})$6"
		],
		"description": "uint imageAtomicMin(gimage1D image,int P,uint data);\nuint imageAtomicMin(gimage2D image,ivec2 P,uint data);\nuint imageAtomicMin(gimage3D image,ivec3 P,uint data);\nuint imageAtomicMin(gimage2DRect image,ivec2 P,uint data);\nuint imageAtomicMin(gimageCube image,ivec3 P,uint data);\nuint imageAtomicMin(gbufferImage image,int P,uint data);\nuint imageAtomicMin(gimage1DArray image,ivec2 P,uint data);\nuint imageAtomicMin(gimage2DArray image,ivec3 P,uint data);\nuint imageAtomicMin(gimageCubeArray image,ivec3 P,uint data);\nuint imageAtomicMin(gimage2DMS image,ivec2 P,int sample,uint data);\nuint imageAtomicMin(gimage2DMSArray image,ivec3 P,int sample,uint data);\nint imageAtomicMin(gimage1D image,int P,int data);\nint imageAtomicMin(gimage2D image,ivec2 P,int data);\nint imageAtomicMin(gimage3D image,ivec3 P,int data);\nint imageAtomicMin(gimage2DRect image,ivec2 P,int data);\nint imageAtomicMin(gimageCube image,ivec3 P,int data);\nint imageAtomicMin(gbufferImage image,int P,int data);\nint imageAtomicMin(gimage1DArray image,ivec2 P,int data);\nint imageAtomicMin(gimage2DArray image,ivec3 P,int data);\nint imageAtomicMin(gimageCubeArray image,ivec3 P,int data);\nint imageAtomicMin(gimage2DMS image,ivec2 P,int sample,int data);\nint imageAtomicMin(gimage2DMSArray image,ivec3 P,int sample,int data);\n\n"
	},

	"imageAtomicOr": {
		"prefix": "imageAtomicOr",
		"body": [
			"imageAtomicOr(${1:image}, ${2:P}${3:, ${4:sample}}, ${5:data})$6"
		],
		"description": "uint imageAtomicOr(gimage1D image,int P,uint data);\nuint imageAtomicOr(gimage2D image,ivec2 P,uint data);\nuint imageAtomicOr(gimage3D image,ivec3 P,uint data);\nuint imageAtomicOr(gimage2DRect image,ivec2 P,uint data);\nuint imageAtomicOr(gimageCube image,ivec3 P,uint data);\nuint imageAtomicOr(gbufferImage image,int P,uint data);\nuint imageAtomicOr(gimage1DArray image,ivec2 P,uint data);\nuint imageAtomicOr(gimage2DArray image,ivec3 P,uint data);\nuint imageAtomicOr(gimageCubeArray image,ivec3 P,uint data);\nuint imageAtomicOr(gimage2DMS image,ivec2 P,int sample,uint data);\nuint imageAtomicOr(gimage2DMSArray image,ivec3 P,int sample,uint data);\nint imageAtomicOr(gimage1D image,int P,int data);\nint imageAtomicOr(gimage2D image,ivec2 P,int data);\nint imageAtomicOr(gimage3D image,ivec3 P,int data);\nint imageAtomicOr(gimage2DRect image,ivec2 P,int data);\nint imageAtomicOr(gimageCube image,ivec3 P,int data);\nint imageAtomicOr(gbufferImage image,int P,int data);\nint imageAtomicOr(gimage1DArray image,ivec2 P,int data);\nint imageAtomicOr(gimage2DArray image,ivec3 P,int data);\nint imageAtomicOr(gimageCubeArray image,ivec3 P,int data);\nint imageAtomicOr(gimage2DMS image,ivec2 P,int sample,int data);\nint imageAtomicOr(gimage2DMSArray image,ivec3 P,int sample,int data);\n\n"
	},

	"imageAtomicXor": {
		"prefix": "imageAtomicXor",
		"body": [
			"imageAtomicXor(${1:image}, ${2:P}${3:, ${4:sample}}, ${5:data})$6"
		],
		"description": "uint imageAtomicXor(gimage1D image,int P,uint data);\nuint imageAtomicXor(gimage2D image,ivec2 P,uint data);\nuint imageAtomicXor(gimage3D image,ivec3 P,uint data);\nuint imageAtomicXor(gimage2DRect image,ivec2 P,uint data);\nuint imageAtomicXor(gimageCube image,ivec3 P,uint data);\nuint imageAtomicXor(gbufferImage image,int P,uint data);\nuint imageAtomicXor(gimage1DArray image,ivec2 P,uint data);\nuint imageAtomicXor(gimage2DArray image,ivec3 P,uint data);\nuint imageAtomicXor(gimageCubeArray image,ivec3 P,uint data);\nuint imageAtomicXor(gimage2DMS image,ivec2 P,int sample,uint data);\nuint imageAtomicXor(gimage2DMSArray image,ivec3 P,int sample,uint data);\nint imageAtomicXor(gimage1D image,int P,int data);\nint imageAtomicXor(gimage2D image,ivec2 P,int data);\nint imageAtomicXor(gimage3D image,ivec3 P,int data);\nint imageAtomicXor(gimage2DRect image,ivec2 P,int data);\nint imageAtomicXor(gimageCube image,ivec3 P,int data);\nint imageAtomicXor(gbufferImage image,int P,int data);\nint imageAtomicXor(gimage1DArray image,ivec2 P,int data);\nint imageAtomicXor(gimage2DArray image,ivec3 P,int data);\nint imageAtomicXor(gimageCubeArray image,ivec3 P,int data);\nint imageAtomicXor(gimage2DMS image,ivec2 P,int sample,int data);\nint imageAtomicXor(gimage2DMSArray image,ivec3 P,int sample,int data);\n\n"
	},

	"imageLoad": {
		"prefix": "imageLoad",
		"body": [
			"imageLoad(${1:image}, ${2:P}${3:, ${4:sample}})$5"
		],
		"description": "gvec4 imageLoad(gimage1D image,int P);\ngvec4 imageLoad(gimage2D image,ivec2 P);\ngvec4 imageLoad(gimage3D image,ivec3 P);\ngvec4 imageLoad(gimage2DRect image,ivec2 P);\ngvec4 imageLoad(gimageCube image,ivec3 P);\ngvec4 imageLoad(gbufferImage image,int P);\ngvec4 imageLoad(gimage1DArray image,ivec2 P);\ngvec4 imageLoad(gimage2DArray image,ivec3 P);\ngvec4 imageLoad(gimageCubeArray image,ivec3 P);\ngvec4 imageLoad(gimage2DMS image,ivec2 P,int sample);\ngvec4 imageLoad(gimage2DMSArray image,ivec3 P,int sample);\n\n"
	},

	"imageSamples": {
		"prefix": "imageSamples",
		"body": [
			"imageSamples(${1:image})$2"
		],
		"description": "int imageSamples(gimage2DMS image);\nint imageSamples(gimage2DMSArray image);\n\n"
	},

	"imageSize": {
		"prefix": "imageSize",
		"body": [
			"imageSize(${1:image})$2"
		],
		"description": "int imageSize(gimage1D image);\nivec2 imageSize(gimage2D image);\nivec3 imageSize(gimage3D image);\nivec2 imageSize(gimageCube image);\nivec3 imageSize(gimageCubeArray image);\nivec2 imageSize(gimageRect image);\nivec2 imageSize(gimage1DArray image);\nivec3 imageSize(gimage2DArray image);\nint imageSize(gimageBuffer image);\nivec2 imageSize(gimage2DMS image);\nivec3 imageSize(gimage2DMSArray image);\n\n"
	},

	"imageStore": {
		"prefix": "imageStore",
		"body": [
			"imageStore(${1:image}, ${2:P}${3:, ${4:sample}}, ${5:data})$6"
		],
		"description": "void imageStore(gimage1D image,int P,gvec4 data);\nvoid imageStore(gimage2D image,ivec2 P,gvec4 data);\nvoid imageStore(gimage3D image,ivec3 P,gvec4 data);\nvoid imageStore(gimage2DRect image,ivec2 P,gvec4 data);\nvoid imageStore(gimageCube image,ivec3 P,gvec4 data);\nvoid imageStore(gbufferImage image,int P,gvec4 data);\nvoid imageStore(gimage1DArray image,ivec2 P,gvec4 data);\nvoid imageStore(gimage2DArray image,ivec3 P,gvec4 data);\nvoid imageStore(gimageCubeArray image,ivec3 P,gvec4 data);\nvoid imageStore(gimage2DMS image,ivec2 P,int sample,gvec4 data);\nvoid imageStore(gimage2DMSArray image,ivec3 P,int sample,gvec4 data);\n\n"
	},

	//Atomic 原子操作

	"atomicAdd": {
		"prefix": "atomicAdd",
		"body": [
			"atomicAdd(${1:mem}, ${2:data})$3"
		],
		"description": "int atomicAdd(inout int mem,int data);\nuint atomicAdd(inout uint mem,uint data);\n\n"
	},

	"atomicAnd": {
		"prefix": "atomicAnd",
		"body": [
			"atomicAnd(${1:mem}, ${2:data})$3"
		],
		"description": "int atomicAnd(inout int mem,int data);\nuint atomicAnd(inout uint mem,uint data);\n\n"
	},

	"atomicCompSwap": {
		"prefix": "atomicCompSwap",
		"body": [
			"atomicCompSwap(${1:mem}, ${2:compare}, ${3:data})$4"
		],
		"description": "int atomicCompSwap(inout int mem,uint compare,uint data);\nuint atomicCompSwap(inout uint mem,uint compare,uint data);\n\n"
	},

	"atomicCounter": {
		"prefix": "atomicCounter",
		"body": [
			"atomicCounter(${1:c})$2"
		],
		"description": "uint atomicCounter(atomic_uint c);\n\n"
	},

	"atomicCounterDecrement": {
		"prefix": "atomicCounterDecrement",
		"body": [
			"atomicCounterDecrement(${1:c})$2"
		],
		"description": "uint atomicCounterDecrement(atomic_uint c);\n\n"
	},

	"atomicCounterIncrement": {
		"prefix": "atomicCounterIncrement",
		"body": [
			"atomicCounterIncrement(${1:c})$2"
		],
		"description": "uint atomicCounterIncrement(atomic_uint c);\n\n"
	},

	"atomicExchange": {
		"prefix": "atomicExchange",
		"body": [
			"atomicExchange(${1:mem}, ${2:data})$3"
		],
		"description": "int atomicExchange(inout int mem,int data);\nuint atomicExchange(inout uint mem,uint data);\n\n"
	},

	"atomicMax": {
		"prefix": "atomicMax",
		"body": [
			"atomicMax(${1:mem}, ${2:data})$3"
		],
		"description": "int atomicMax(inout int mem,int data);\nuint atomicMax(inout uint mem,uint data);\n\n"
	},

	"atomicMin": {
		"prefix": "atomicMin",
		"body": [
			"atomicMin(${1:mem}, ${2:data})$3"
		],
		"description": "int atomicMin(inout int mem,int data);\nuint atomicMin(inout uint mem,uint data);\n"
	},

	"atomicOr": {
		"prefix": "atomicOr",
		"body": [
			"atomicOr(${1:mem}, ${2:data})$3"
		],
		"description": "int atomicOr(inout int mem,int data);\nuint atomicOr(inout uint mem,uint data);\n\n"
	},

	"atomicXor": {
		"prefix": "atomicXor",
		"body": [
			"atomicXor(${1:mem}, ${2:data})$3"
		],
		"description": "int atomicXor(inout int mem,int data);\nuint atomicXor(inout uint mem,uint data);\n\n"
	},

	//Memory Barrier 内存屏障/屏障指令

	"barrier": {
		"prefix": "barrier",
		"body": [
			"barrier()$1"
		],
		"description": "void barrier(void);\n\n"
	},

	"groupMemoryBarrier": {
		"prefix": "groupMemoryBarrier",
		"body": [
			"groupMemoryBarrier()$1"
		],
		"description": "void groupMemoryBarrier(void);\n\n等待计算着色器调用执行的所有内存访问完成,将对于同一工作组中其它调用执行的相同访问,然后返回没有其他效果\n\n"
	},

	"memoryBarrier": {
		"prefix": "memoryBarrier",
		"body": [
			"memoryBarrier()$1"
		],
		"description": "void memoryBarrier(void);\n\n"
	},

	"memoryBarrierAtomicCounter": {
		"prefix": "memoryBarrierAtomicCounter",
		"body": [
			"memoryBarrierAtomicCounter()$1"
		],
		"description": "void memoryBarrierAtomicCounter(void);\n\n"
	},

	"memoryBarrierBuffer": {
		"prefix": "memoryBarrierBuffer",
		"body": [
			"memoryBarrierBuffer()$1"
		],
		"description": "void memoryBarrierBuffer(void);\n\n"
	},

	"memoryBarrierImage": {
		"prefix": "memoryBarrierImage",
		"body": [
			"memoryBarrierImage()$1"
		],
		"description": "void memoryBarrierImage(void);\n\n"
	},

	"memoryBarrierShared": {
		"prefix": "memoryBarrierShared",
		"body": [
			"memoryBarrierShared()$1"
		],
		"description": "void memoryBarrierShared(void);\n\n"
	},

	//预处理

	"#version": {
		"prefix": "#version",
		"body": [
			"#version ${1:ver}"
		],
		"description": "可选值:\n#version 110          // GLSL 1.1         OpenGL 2.0  【默认】\n#version 120          // GLSL 1.2         OpenGL 2.1\n#version 130          // GLSL 1.3         OpenGL 3.0\n#version 140          // GLSL 1.4         OpenGL 3.1\n#version 150          // GLSL 1.5         OpenGL 3.2\n#version 330          // GLSL 3.3         OpenGL 3.3\n#version 330 core     // GLSL 3.3核心模式   OpenGL 3.3\n#version 400          // GLSL 4.0         OpenGL 4.0\n#version 410          // GLSL 4.1         OpenGL 4.1\n#version 420          // GLSL 4.2         OpenGL 4.2\n#version 430          // GLSL 4.3         OpenGL 4.3\n#version 440          // GLSL 4.4         OpenGL 4.4\n#version 450          // GLSL 4.5         OpenGL 4.5\n#version 460          // GLSL 4.6         OpenGL 4.6\n\n#version 150 compatibility // GLSL 1.5 并向前兼容GLSL 1.2、1.3、1.4的语法\n\n#version 300 es // GLSL ES 3.0 或称 ESSL 3.0   注:声明为这个后,宏GL_ES会被定义为1\n\n"
	},

	"#extension": {
		"prefix": "#extension",
		"body": [
			"#extension  ${1:extname} : ${2:behaivor}"
		],
		"description": "extname为编译器支持的扩展名称\nbehaivor可以是require、enable、warn、disable\n   require  扩展是必需的。若当前扩展不受支持,将抛出错误\n   enable  启用扩展。若当前扩展不支持,将抛出警告\n   warn  对于扩展的任何使用均抛出警告\n   disable  禁用扩展。若当前扩展被使用,将抛出错误\n\n"
	},

	"#if": {
		"prefix": "#if ",
		"body": [
			"#if"
		],
		"description": ""
	},

	"#elif": {
		"prefix": "#elif ",
		"body": [
			"#elif"
		],
		"description": ""
	},

	"#else": {
		"prefix": "#else ",
		"body": [
			"#else"
		],
		"description": ""
	},

	"#ifdef": {
		"prefix": "#ifdef ",
		"body": [
			"#ifdef "
		],
		"description": ""
	},

	"#ifndef": {
		"prefix": "#ifndef ",
		"body": [
			"#ifndef "
		],
		"description": ""
	},

	"#endif": {
		"prefix": "#endif",
		"body": [
			"#endif"
		],
		"description": ""
	},

	"#define": {
		"prefix": "#define ${1:def}",
		"body": [
			"#define "
		],
		"description": "宏定义\n\n"
	},

	"#undef": {
		"prefix": "#undef ${1:def}",
		"body": [
			"#undef"
		],
		"description": "宏取消\n\n"
	},

	"#line": {
		"prefix": "#line",
		"body": [
			"#line ${1:lineNum} ${2:ID}"
		],
		"description": "指示下一行的行号,及当前所在的文件;该命令会修改__FILE__、__LINE__的值\n\n该命令是提供给编译器使用的,程序员最好不要使用该命令\n\n"
	},

	"#pragma": {
		"prefix": "#pragma",
		"body": [
			"#pragma ${1:p}"
		],
		"description": "用来控制编译器的一些行为\n\n#pragma optimize(on) // 开启编译器优化 【默认】\n#pragma optimize(off) // 关闭编译器优化\n#pragma debug(on)  // 开启debug选项,以获得更多的调试信息\n#pragma debug(off) // 关闭debug选项 【默认】\n\n#pragma STDGL invariant(all)  // 让所有的变量全都不变\n\n注:因为编译器需要保证不变性,所以会限制对着色器进行优化\n\n"
	},

	"#error": {
		"prefix": "#error",
		"body": [
			"#error ${1:info}"
		],
		"description": "error命令被执行,会导致当前文件编译失败\n\n"
	},

	"__VERSION__": {
		"prefix": "_version_",
		"body": [
			"__VERSION__ "
		],
		"description": "__VERSION__为内置宏,int类型,为当前GLSL文件的版本号\n\n"
	},

	"__FILE__": {
		"prefix": "_file_",
		"body": [
			"__FILE__ "
		],
		"description": "宏__FILE__为int类型,当前Source String的唯一ID标识\n\n"
	},

	"__LINE__": {
		"prefix": "_line_",
		"body": [
			"__LINE__ "
		],
		"description": "宏__LINE__为int类型,当前的行号\n\n"
	},

	"GL_ES": {
		"prefix": "GL_ES",
		"body": [
			"GL_ES"
		],
		"description": "OpenGL下,内置宏GL_ES未定义,条件不成立;openGL es下,GL_ES为1,条件成立\n\n"
	},

	"GL_FRAGMENT_PRECISION_HIGH": {
		"prefix": "GL_FRAGMENT_PRECISION_HIGH",
		"body": [
			"GL_FRAGMENT_PRECISION_HIGH"
		],
		"description": "若当前片元着色器支持高浮点精度,则宏GL_FRAGMENT_PRECISION_HIGH为1\n\n"
	},

	"precision": {
		"prefix": "precision",
		"body": [
			"precision ${1|highp,mediump,lowp|} ${2:type}"
		],
		"description": "设置type的精度为p\np有三种:\n  highp - 高精度\n  mediump - 中精度\n  lowp - 低精度\n\n"
	},

	"highp": {
		"prefix": "highp",
		"body": [
			"highp"
		],
		"description": "vs的最低精度\n注:在某些webgl环境中,fs可能不支持highp精度,如果支持的话,会定义内置宏GL_FRAGMENT_PRECISION_HIGH\n\nfloat数值范围和精度:\n  范围:(-2^62~2^62)\n  精度:2^-16\n\nint数值范围:(-2^16~2^16)\n\n"
	},

	"mediump": {
		"prefix": "mediump",
		"body": [
			"mediump"
		],
		"description": "fs的最低精度\n\nfloat数值范围和精度:\n  范围:(-2^14~2^14)\n  精度:2^-10\n\nint数值范围:(-2^10~2^10)\n\n"
	},

	"lowp": {
		"prefix": "lowp",
		"body": [
			"lowp"
		],
		"description": "可以表示所有的颜色\n\nfloat数值范围和精度:\n  范围:(-2~2)\n  精度:2^-8\n\nint数值范围:(-2^8~2^8)\n\n"
	},

	"layout-location": {
		"prefix": "layout-location",
		"body": [
			"layout (location = ${1:0}) "
		],
		"description": ""
	},

	"layout": {
		"prefix": "layout",
		"body": [
			"layout (${1:lay}) "
		],
		"description": "lay可选值:\n  shared(默认)  多个着色器程序间共享。可省略不写\n  packed  最小内存占用,无法在多个着色器程序间共享\n  std140  标准内存布局\n  column_major(默认)  矩阵变量以列优先顺序。可省略不写\n  row_major  矩阵变量以行优先顺序\n\n"
	},

	"shared": {
		"prefix": "shared",
		"body": [
			"shared"
		],
		"description": ""
	},

	"packed": {
		"prefix": "packed",
		"body": [
			"packed"
		],
		"description": ""
	},

	"std140": {
		"prefix": "std140",
		"body": [
			"std140"
		],
		"description": ""
	},

	"column_major": {
		"prefix": "column_major",
		"body": [
			"column_major"
		],
		"description": ""
	},

	"row_major": {
		"prefix": "row_major",
		"body": [
			"row_major"
		],
		"description": ""
	},

	"uniform": {
		"prefix": "uniform",
		"body": [
			"uniform "
		],
		"description": "是只读的,与顶点和像素无关的输入型变量,被用来表示非逐顶点、非逐像素、各顶点、各像素共用的信息,必须声明为全局变量,可在vs和fs中使用\n可以是除了数组或结构体之外的任意类型。如果vs和fs中声明了同名的统一变量(uniform变量),那么它就会被两种着色器共享\n\n"
	},

	"in": {
		"prefix": "in",
		"body": [
			"in "
		],
		"description": ""
	},

	"out": {
		"prefix": "out",
		"body": [
			"out "
		],
		"description": ""
	},

	"inout": {
		"prefix": "inout",
		"body": [
			"inout "
		],
		"description": ""
	},

	"invariant": {
		"prefix": "invariant",
		"body": [
			"invariant "
		],
		"description": "为了保证不变性,GLSL引入了invariant关键字来修饰顶点输出变量。\n主要的原因是,为了优化,编译器可能对shader指令重新排序,可能导致2个着色器之间的等价计算不能保证产生完全相同的结果。特别是在进行多遍渲染时,尤其可能成为问题。\n例如:fs中第一遍中计算镜面反射光,第二遍计算环境光和漫反射光,顶点输出变量如果不使用invariant关键字,精度带来的小误差会导致深度冲突(Z fighting)。\ninvariant关键字既可用于声明变量,也可以用于已经声明过的变量。\n\ninvariant vec2 texCoord; // 用于声明变量\ninvariant gl_Position;  // 用于已经声明过的变量\n#pragma STDGL invariant(all)  // 让所有的变量全都不变   注：因为编译器需要保证不变性，所以会限制对着色器进行优化\n\n"
	},

	"smooth": {
		"prefix": "smooth",
		"body": [
			"smooth "
		],
		"description": "平滑着色\n\n/*** vs ***/\nsmooth out vec3 v_color;  // smooth可省略不写\n\n/*** fs ***/\nsmooth in vec3 v_color;  // smooth可省略不写\n\n"
	},

	"flat": {
		"prefix": "flat",
		"body": [
			"flat "
		],
		"description": "平面着色\n\n/*** vs ***/\nflat out vec3 v_color;\n\n/*** fs ***/\nflat in vec3 v_color;\n\n"
	},

	"centroid": {
		"prefix": "centroid",
		"body": [
			"centroid "
		],
		"description": "质心采样(centroid sampling)\n使用多重采样渲染时,centroid可用于强制插值发生在被渲染图元内部\n这可防止图元的边缘出现伪像\n\n/*** vs ***/\ncentroid out vec3 v_color;\n\n/*** fs ***/\ncentroid in vec3 v_color;\n\n"
	},

	"struct": {
		"prefix": "struct",
		"body": [
			"struct ${1:name}{",
			"\t$0",
			"}"
		],
		"description": ""
	},

	"const": {
		"prefix": "const",
		"body": [
			"const "
		],
		"description": ""
	},

	"attritude": {
		"prefix": "attritude",
		"body": [
			"attritude "
		],
		"description": ""
	},

	"varying": {
		"prefix": "varying",
		"body": [
			"varying "
		],
		"description": ""
	},

	//数据类型

	"void": {
		"prefix": "void",
		"body": [
			"void "
		],
		"description": ""
	},

	"int": {
		"prefix": "int",
		"body": [
			"int "
		],
		"description": "整形\n\n"
	},

	"float": {
		"prefix": "float",
		"body": [
			"float "
		],
		"description": "单精度浮点\n\n"
	},

	"double": {
		"prefix": "double",
		"body": [
			"double "
		],
		"description": "双精度浮点\n\n"
	},

	"bool": {
		"prefix": "bool",
		"body": [
			"bool "
		],
		"description": "布尔\n\n"
	},

	"uint": {
		"prefix": "uint",
		"body": [
			"uint "
		],
		"description": "无符号整形\n\n"
	},

	"vec": {
		"prefix": "vec",
		"body": [
			"vec${1|1,2,3,4|} "
		],
		"description": "float向量\n\n"
	},

	"bvec": {
		"prefix": "bvec",
		"body": [
			"bvec${1|1,2,3,4|} "
		],
		"description": "bool向量\n\n"
	},

	"uvec": {
		"prefix": "uvec",
		"body": [
			"uvec${1|1,2,3,4|} "
		],
		"description": "无符号整型向量\n\n"
	},

	"ivec": {
		"prefix": "ivec",
		"body": [
			"ivec${1|1,2,3,4|} "
		],
		"description": "整型向量\n\n"
	},

	"mat": {
		"prefix": "mat",
		"body": [
			"mat${1|2,2x3,2x4,3x2,3,3x4,4x2,4x3,4|} "
		],
		"description": "矩阵,分量类型均为float\n\n"
	},

	//浮点采样器(不透明)

	"sampler1D": {
		"prefix": "sampler1D",
		"body": [
			"sampler1D "
		],
		"description": "1D纹理\n\n"
	},

	"sampler2D": {
		"prefix": "sampler2D",
		"body": [
			"sampler2D "
		],
		"description": "2D纹理\n\n"
	},

	"sampler3D": {
		"prefix": "sampler3D",
		"body": [
			"sampler3D "
		],
		"description": "3D纹理\n\n"
	},

	"samplerCube": {
		"prefix": "samplerCube",
		"body": [
			"samplerCube "
		],
		"description": "立方图纹理\n\n"
	},

	"samplerCubeShadow": {
		"prefix": "samplerCubeShadow",
		"body": [
			"samplerCubeShadow "
		],
		"description": "带有对比的立方图深度纹理\n\n"
	},

	"sampler1DShadow": {
		"prefix": "sampler1DShadow",
		"body": [
			"sampler1DShadow "
		],
		"description": "带有对比的1D深度纹理\n\n"
	},

	"sampler1DArray": {
		"prefix": "sampler1DArray",
		"body": [
			"sampler1DArray "
		],
		"description": "1D数组纹理\n\n"
	},
	"sampler1DArrayShadow": {
		"prefix": "sampler1DArrayShadow",
		"body": [
			"sampler1DArrayShadow "
		],
		"description": "带有对比的1D数组深度纹理\n\n"
	},

	"sampler2DShadow": {
		"prefix": "sampler2DShadow",
		"body": [
			"sampler2DShadow "
		],
		"description": "带有对比的2D深度纹理\n\n"
	},

	"sampler2DArray": {
		"prefix": "sampler2DArray",
		"body": [
			"sampler2DArray "
		],
		"description": "2D数组纹理\n\n"
	},

	"sampler2DArrayShadow": {
		"prefix": "sampler2DArrayShadow",
		"body": [
			"sampler2DArrayShadow "
		],
		"description": "带有对比的2D数组深度纹理\n\n"
	},

	//有符号整数采样器(不透明)

	"isampler1D": {
		"prefix": "isampler1D",
		"body": [
			"isampler1D "
		],
		"description": "有符号整数1D纹理\n\n"
	},

	"isampler2D": {
		"prefix": "isampler2D",
		"body": [
			"isampler2D "
		],
		"description": "有符号整数2D纹理\n\n"
	},

	"isampler3D": {
		"prefix": "isampler3D",
		"body": [
			"isampler3D "
		],
		"description": "有符号整数3D纹理\n\n"
	},

	"isamplerCube": {
		"prefix": "isamplerCube",
		"body": [
			"isamplerCube "
		],
		"description": "有符号整数立方图纹理\n\n"
	},

	"isampler1DArray": {
		"prefix": "isampler1DArray",
		"body": [
			"isampler1DArray "
		],
		"description": "有符号整数1D数组纹理\n\n"
	},

	"isampler2DArray": {
		"prefix": "isampler2DArray",
		"body": [
			"isampler2DArray "
		],
		"description": "有符号整数2D数组纹理\n\n"
	},

	//无符号整数采样器(不透明)

	"usampler1D": {
		"prefix": "usampler1D",
		"body": [
			"usampler1D "
		],
		"description": "无符号整数1D纹理\n\n"
	},

	"usampler2D": {
		"prefix": "usampler2D",
		"body": [
			"usampler2D "
		],
		"description": "无符号整数2D纹理\n\n"
	},

	"usampler3D": {
		"prefix": "usampler3D",
		"body": [
			"usampler3D "
		],
		"description": "无符号整数3D纹理\n\n"
	},

	"usamplerCube": {
		"prefix": "usamplerCube",
		"body": [
			"usamplerCube "
		],
		"description": "无符号整数立方图纹理\n\n"
	},

	"usampler1DArray": {
		"prefix": "usampler1DArray",
		"body": [
			"usampler1DArray "
		],
		"description": "无符号整数1D数组纹理\n\n"
	},

	"usampler2DArray": {
		"prefix": "usampler2DArray",
		"body": [
			"usampler2DArray "
		],
		"description": "无符号整数2D数组纹理\n\n"
	},

	//流程控制

	"for": {
		"prefix": "for",
		"body": [
			"for(int ${1:i} = 0, ${1:i} < ${2:n}, ${1:i}++){",
			"\t$0",
			"}"
		],
		"description": ""
	},

	"while": {
		"prefix": "while",
		"body": [
			"while(${1:condition}){",
			"\t$0",
			"}"
		],
		"description": ""
	},

	"dowhile": {
		"prefix": "dowhile",
		"body": [
			"do{",
			"\t$0",
			"}while(${1:condition});"
		],
		"description": ""
	},

	"continue": {
		"prefix": "continue",
		"body": [
			"continue;"
		],
		"description": ""
	},

	"break": {
		"prefix": "break",
		"body": [
			"break;"
		],
		"description": ""
	},

	"discard": {
		"prefix": "discard",
		"body": [
			"discard;"
		],
		"description": "该关键字只能在fs中使用,表示放弃当前片元,直接处理下一个片元。\n\n"
	},

	"if": {
		"prefix": "if",
		"body": [
			"if(${1:condition}){",
			"\t$0",
			"}"
		],
		"description": ""
	},

	"else": {
		"prefix": "else",
		"body": [
			"else{",
			"\t$0",
			"}"
		],
		"description": ""
	},

	"elseif": {
		"prefix": "elseif",
		"body": [
			"else if(${1:condition}){",
			"\t$0",
			"}"
		],
		"description": ""
	},

	"return": {
		"prefix": "return",
		"body": [
			"return "
		],
		"description": ""
	},

	"switch": {
		"prefix": "switch",
		"body": [
			"switch(${1:int}){",
			"\t$0",
			"",
			"\tdefault:",
			"\t\t${2:exp}"
		],
		"description": ""
	},

	"case": {
		"prefix": "case",
		"body": [
			"case ${1:int}:",
			"\t$0",
			"\tbreak;"
		],
		"description": "\n\n"
	},

	//costume 自定义片段

	"PI": {
		"prefix": "PI",
		"body": [
			"const float PI = 3.14159265359;"
		],
		"description": "PI setup"
	},

	"ifdef": {
		"prefix": "ifdef",
		"body": [
			"#ifdef GL_ES",
			"precision mediump float;",
			"#endif"
		],
		"description": "A check defining if GLES is available"
	},

	"ifdef-extension": {
		"prefix": "ifdef-extension",
		"body": [
			"#ifdef GL_OES_standard_derivatives",
				"#extension GL_OES_standard_derivatives : enable",
			"#endif"
		],
		"description": "扩展,启用fwidth等函数"
	},

	"simple setup": {
		"prefix": "simple setup",
		"body": [
			"#ifdef GL_ES",
			"precision mediump float;",
			"#endif",
			"",
			"uniform float u_time;",
			"uniform vec2 u_resolution;",
			"uniform vec2 u_mouse;",
			"",
			"vec2 fixUV(){",
			"\tvec2 st = (gl_FragCoord.xy - u_resolution * 0.5) / min(u_resolution.x, u_resolution.y) * 1.0;",
			"",
			"\treturn st;",
			"}",
			"",
			"void main(){",
			"\tvec2 uv = fixUV();",
			"\tvec3 color = vec3(0.0, 1.0, 1.0);",
			"",
			"\tgl_FragColor = vec4(color, 1.0);",
			"}"
		],
		"description": "Starter code including 'ifdef' check, u_ methods & the main"
	},

	"": {
		"prefix": "",
		"body": [
			""
		],
		"description": "\n\n"
	}

}
